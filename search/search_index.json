{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"reference/SUMMARY/","text":"parsers entry gedcom_file","title":"SUMMARY"},{"location":"reference/parsers/","text":"hello entry Entry!!! Entry Class to manage an entry. Where an entry is an entire INDI, FAM, or SOUR entry in a gedcom file Source code in parsers/entry.py class Entry : \"\"\"Class to manage an entry. Where an entry is an entire INDI, FAM, or SOUR entry in a gedcom file\"\"\" _EMPTY_LINE_PLACEHOLDER = \"<<NONE>>\" _CONT_PLACEHOLDER = \"<<CONT>>\" _MISSING_DATA_PLACEHOLDER = \"<<MISSING DATA>>\" _CONT_RE = re . compile ( \"^\\d+ CONT (?P<value>.*)\" ) _CONC_RE = re . compile ( \"^\\d+ CONC (?P<value>.*)\" ) _EMPTY_LINE_RE = re . compile ( r \"^\\d+ [A-Z_]{3,5}$\" ) _FIRST_LINE_RE = re . compile ( r \"^0 (?P<id>@[IFS]\\d+@) (?P<type>(?:INDI|FAM|SOUR))$\" ) _DATE_TAG = \"DATE\" _ACTIVE_TAG_SEPARATOR = \"+\" _SUFFIX_SEPARATOR = \"~\" def __init__ ( self , lines : List [ str ], force_string_dates : bool , no_cont_conc : bool ) -> None : f \"\"\" Parameters ---------- lines: List[str] A list of strings where each item in the list is a line of a gedcome file pertaining to the entry. The order is assumed to be top -> bottom as if reading the gedcom file force_string_dates: bool A flag that, when True, will add a single-quote (') in front of DATE values. This should force excel to render these values as strings rather than attempt to interpret them as dates. Which it isn't super good at. no_cont_conc: bool A flag that, when True, disables attempts to preserve all CONT and CONC data. Instead a missing data string is put in place of CONT and CONC continued/concatenated values. \"\"\" # the first line is not like the others. It contians the type of entry, and the id number self . ENTRY_DEBUG = env ( \"VERBOSE_OUTPUT\" , cast = bool , default = False ) # set self.id and self.type for k , v in self . get_first_line_dict ( lines [ 0 ]) . items (): setattr ( self , k , v ) self . force_string_dates = force_string_dates self . no_cont_conc = no_cont_conc self . lines = lines [ 1 :] @staticmethod def get_first_line_dict ( line ) -> dict : \"\"\"Parses the first line of an entry and returns a dict with the groups defined in _FIRST_LINE_RE\"\"\" match = Entry . _FIRST_LINE_RE . match ( line ) assert match return match . groupdict () @property def lines ( self ) -> List [ str ]: \"\"\"Returns self.lines as a list of strings\"\"\" return self . add_cont_conc ([ l . to_str () for l in self . _lines ]) @lines . setter def lines ( self , val ) -> None : \"\"\"Sets self.lines. Stores lines as line objects under the hood\"\"\" if not isinstance ( val , list ): raise ValueError ( f \"lines must be an instance of list, go { type ( val ) } \" ) elif not all ([ isinstance ( v , str ) for v in val ]): raise ValueError ( \"All lines must be string values\" ) else : if self . no_cont_conc : self . _lines = [ Line . from_str ( l ) for l in self . remove_cont_conc ( val )] else : self . _lines = [ Line . from_str ( l ) for l in self . collapse_cont_conc ( val )] def remove_cont_conc ( self , lines : List [ str ]) -> List [ str ]: r \"\"\"Removes CONT and CONC tags from a list of lines. Replaces them with a warning string Parameters ---------- lines: List[str] A list of gedcom file lines Returns ------- List[str] The processed gedcome file lines with CONT and CONC tags removed Example ------- Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long<<MISSING DATA>>\"] \"\"\" ret = [] skip = False for i , line in enumerate ( lines ): # eliminate trailing newline characters if line . endswith ( \" \\n \" ): line = line [: - 1 ] if self . _CONT_RE . match ( line ) or self . _CONC_RE . match ( line ): assert i > 0 # the logic in the below else statement should only be executed once per series of CONT/CONCs. So, # skip is set to True on the first CONT/CONC found and it is handled. Then it is re-set to False # upon detecting the next line that does not contain a CONT/CONC tag if skip : pass else : prev_line = ret [ - 1 ] skip = True if len ( prev_line ) > GEDCOM_MAX_LINE_LENGTH - len ( self . _MISSING_DATA_PLACEHOLDER ): # cut off the previous line so that the missing data placeholder can fit, then append the missing data placeholder ret [ - 1 ] = f \" { prev_line [: GEDCOM_MAX_LINE_LENGTH - len ( self . _MISSING_DATA_PLACEHOLDER )] }{ self . _MISSING_DATA_PLACEHOLDER } \" elif self . _EMPTY_LINE_RE . match ( prev_line ): # Add the missing data placeholder, but make sure there is a space between it and the tag prev_line = f \" { prev_line } { self . _MISSING_DATA_PLACEHOLDER } \" else : # Add the missing data placeholder prev_line = f \" { prev_line }{ self . _MISSING_DATA_PLACEHOLDER } \" else : skip = False ret . append ( line ) if self . ENTRY_DEBUG : print ( \"REMOVE_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret def collapse_cont_conc ( self , lines : List [ str ]) -> List [ str ]: r \"\"\"Accepts a list of strings, combines lines that are contineud via CONT/CONC. Returns the modified list Parameters ---------- lines: List[str] A list of gedcom file lines Returns ------- List[str] The processed gedcome file lines with CONT and CONC folded up into the lines that they continued/concatenated Example ------- Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long<<CONT>>long long long long long long note\"] \"\"\" \"\"\"Removes CONT and CONC tags in a list of lines by combining those lines into one line\"\"\" ret = [] for i , line in enumerate ( lines ): # remove errant trailing newline characters if line . endswith ( \" \\n \" ): line = line [: - 1 ] cont_match = self . _CONT_RE . match ( line ) conc_match = self . _CONC_RE . match ( line ) assert not ( cont_match and conc_match ) if cont_match : assert i != 0 if self . _EMPTY_LINE_RE . match ( ret [ - 1 ]): # if ret[-1] is nothing but a depth and tag, there needs to be a space before the CONT ret [ - 1 ] = f \" { ret [ - 1 ] } { self . _CONT_PLACEHOLDER }{ cont_match . groupdict ()[ 'value' ] } \" else : ret [ - 1 ] = f \" { ret [ - 1 ] }{ self . _CONT_PLACEHOLDER }{ cont_match . groupdict ()[ 'value' ] } \" elif conc_match : assert i != 0 assert not self . _EMPTY_LINE_RE . match ( ret [ - 1 ]) # simply append the concatenated value. No need to check for empty tags as by definition, conc # tags are not applied to empty lines ret [ - 1 ] = f \" { ret [ - 1 ] }{ conc_match . groupdict ()[ 'value' ] } \" else : # no processing necessary. Just append and move on ret . append ( line ) if self . ENTRY_DEBUG : print ( \"COLLAPSE_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret @staticmethod def add_cont_conc ( lines : List [ str ]) -> List [ str ]: def get_tag_value_chunk ( depth : Union [ int , str ], tag : str , tag_value : str ): \"\"\"Helper function to determine when and how to split a tag value Parameters ---------- depth: Union[int, str] the depth value for the line being examined tag: str the tag for the line being examined. E.g. DATE, PLAC or BURI tag_value: str the rest of the line being examined Returns ------- Tuple[bool, str, str, Union[str, None]] [0] - boolean: whether the tag_value needed to be split or not [1] - str: The tag for this line. Original tag, CONC, or CONT [2] - str: the value of the split-off section of tag_value [3] - str|None: the remainder of tag_value \"\"\" ret = ( False , tag , tag_value , None ) if tag_value is not None : len_depth = len ( str ( depth )) len_tag = len ( tag ) len_tag_value = len ( tag_value ) num_spaces = 2 if ( len_depth + len_tag + len_tag_value + num_spaces > GEDCOM_MAX_LINE_LENGTH or tag_value . find ( Entry . _CONT_PLACEHOLDER ) != - 1 ): newline_index = tag_value . find ( Entry . _CONT_PLACEHOLDER ) if newline_index != - 1 : if ( len_depth + len_tag + num_spaces + newline_index ) < GEDCOM_MAX_LINE_LENGTH : ret = ( True , \"CONT\" , tag_value . split ( Entry . _CONT_PLACEHOLDER )[ 0 ], Entry . _CONT_PLACEHOLDER . join ( tag_value . split ( Entry . _CONT_PLACEHOLDER )[ 1 :] ), ) else : ret = ( True , \"CONC\" , tag_value [ : GEDCOM_MAX_LINE_LENGTH - 1 - len_depth - len_tag - num_spaces ], tag_value [ GEDCOM_MAX_LINE_LENGTH - 1 - len_depth - len_tag - num_spaces : ], ) else : ret = ( True , \"CONC\" , tag_value [: GEDCOM_MAX_LINE_LENGTH - len_depth - len_tag - num_spaces ], tag_value [ GEDCOM_MAX_LINE_LENGTH - len_depth - len_tag - num_spaces :], ) else : pass else : pass return ret if env ( \"VERBOSE_OUTPUT\" , cast = bool , default = False ): print ( \"ADD_CONT_CONC input:\" ) for x in lines : print ( f \" \\t { x } \" ) ret = [] for i , line in enumerate ( lines ): depth = int ( Line . get_depth_from_line ( line )) tag = Line . get_tag_from_line ( line ) tag_value = Line . get_tag_value_from_line ( line ) need_split , new_tag , tag_value , next_tag_value = get_tag_value_chunk ( depth , tag , tag_value ) ret . append ( f \" { depth } { tag } { tag_value } \" ) while need_split : ( need_split , new_tag , prev_tag_value , next_tag_value ) = get_tag_value_chunk ( depth + 1 , new_tag , next_tag_value ) if prev_tag_value : ret . append ( f \" { depth + 1 } { new_tag } { prev_tag_value } \" ) else : ret . append ( f \" { depth + 1 } { new_tag } \" ) if env ( \"VERBOSE_OUTPUT\" , cast = bool , default = False ): print ( \"ADD_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret def to_col_name_dict ( self ): \"\"\"Transform lines into a CSV-file-friendly dictionary of col-title:value pairs Tags are folded into eachother so that one entry can occupy a single row of the CSV file. E.g. 0 @I42@ INDI 1 NAME Leonard Frank /Bartos/ 2 GIVN Leonard Frank 2 NSFX RPh 1 SEX M 1 _UID 4EF44217DF0F40419968D80B5CC5FE8491FB becomes { \"type\": \"INDI\", \"id:\" @I42@\", \"NAME\": \"Leonard Frand /Bartos/\", \"NAME+GIVN\": \"Leonard Frank\", \"NAME+NSFX\": \"RPh\", \"SEX\": \"M\", \"_UID\": \"4EF44217DF0F40419968D80B5CC5FE8491FB\", } \"\"\" # at minimum, id and type is needed ret = { \"id\" : self . id , \"tag_type\" : self . type } # a stack of active tags. The tags are concatenated together to form column headers active_tags = [] # iterate through the Line objects directly for i , line in enumerate ( self . _lines ): # Pop all no-longer-active tags off of the stack. The current line's depth - 1 # indicates how many of the active tags are still relevant. (The current line contributes # an active tag. Thus, the length of active tags should always equal the depth of the line if line . depth <= len ( active_tags ) + 1 : active_tags = active_tags [: ( line . depth - 1 )] active_tags . append ( line . tag ) # process tag_value. Tags with no value need a placeholder and date tags may need # adjusting depending on force_string_dates if line . tag_value is None : tag_value = self . _EMPTY_LINE_PLACEHOLDER elif ( line . tag == self . _DATE_TAG and self . force_string_dates and not line . tag . startswith ( \"'\" ) ): tag_value = f \"' { line . tag_value } \" else : tag_value = line . tag_value # Ensure unique column headers. E.g. if there are two NAME entries in a record and each # has a GIVN sub-property, the dictionary should look like: # { # \"NAME+GIVN\": \"value\", # \"NAME+GIVN_1\": \"other value\", # } suffix = 0 while self . _ACTIVE_TAG_SEPARATOR . join ( active_tags ) in ret : suffix += 1 active_tags [ - 1 ] = f \" { line . tag }{ self . _SUFFIX_SEPARATOR }{ suffix } \" ret [ \"+\" . join ( active_tags )] = tag_value if self . ENTRY_DEBUG : print ( \"--ENTRY AS DICT--\" ) for k , v in ret . items (): print ( f \" \\t { k } : { v } \" ) return ret lines : List [ str ] property writable Returns self.lines as a list of strings collapse_cont_conc ( self , lines ) Accepts a list of strings, combines lines that are contineud via CONT/CONC. Returns the modified list Parameters !!! lines \"List[str]\" A list of gedcom file lines Returns List[str] The processed gedcome file lines with CONT and CONC folded up into the lines that they continued/concatenated Example Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long< >long long long long long long note\"] Source code in parsers/entry.py def collapse_cont_conc ( self , lines : List [ str ]) -> List [ str ]: r \"\"\"Accepts a list of strings, combines lines that are contineud via CONT/CONC. Returns the modified list Parameters ---------- lines: List[str] A list of gedcom file lines Returns ------- List[str] The processed gedcome file lines with CONT and CONC folded up into the lines that they continued/concatenated Example ------- Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long<<CONT>>long long long long long long note\"] \"\"\" \"\"\"Removes CONT and CONC tags in a list of lines by combining those lines into one line\"\"\" ret = [] for i , line in enumerate ( lines ): # remove errant trailing newline characters if line . endswith ( \" \\n \" ): line = line [: - 1 ] cont_match = self . _CONT_RE . match ( line ) conc_match = self . _CONC_RE . match ( line ) assert not ( cont_match and conc_match ) if cont_match : assert i != 0 if self . _EMPTY_LINE_RE . match ( ret [ - 1 ]): # if ret[-1] is nothing but a depth and tag, there needs to be a space before the CONT ret [ - 1 ] = f \" { ret [ - 1 ] } { self . _CONT_PLACEHOLDER }{ cont_match . groupdict ()[ 'value' ] } \" else : ret [ - 1 ] = f \" { ret [ - 1 ] }{ self . _CONT_PLACEHOLDER }{ cont_match . groupdict ()[ 'value' ] } \" elif conc_match : assert i != 0 assert not self . _EMPTY_LINE_RE . match ( ret [ - 1 ]) # simply append the concatenated value. No need to check for empty tags as by definition, conc # tags are not applied to empty lines ret [ - 1 ] = f \" { ret [ - 1 ] }{ conc_match . groupdict ()[ 'value' ] } \" else : # no processing necessary. Just append and move on ret . append ( line ) if self . ENTRY_DEBUG : print ( \"COLLAPSE_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret get_first_line_dict ( line ) staticmethod Parses the first line of an entry and returns a dict with the groups defined in _FIRST_LINE_RE Source code in parsers/entry.py @staticmethod def get_first_line_dict ( line ) -> dict : \"\"\"Parses the first line of an entry and returns a dict with the groups defined in _FIRST_LINE_RE\"\"\" match = Entry . _FIRST_LINE_RE . match ( line ) assert match return match . groupdict () remove_cont_conc ( self , lines ) Removes CONT and CONC tags from a list of lines. Replaces them with a warning string Parameters !!! lines \"List[str]\" A list of gedcom file lines Returns List[str] The processed gedcome file lines with CONT and CONC tags removed Example Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long< >\"] Source code in parsers/entry.py def remove_cont_conc ( self , lines : List [ str ]) -> List [ str ]: r \"\"\"Removes CONT and CONC tags from a list of lines. Replaces them with a warning string Parameters ---------- lines: List[str] A list of gedcom file lines Returns ------- List[str] The processed gedcome file lines with CONT and CONC tags removed Example ------- Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long<<MISSING DATA>>\"] \"\"\" ret = [] skip = False for i , line in enumerate ( lines ): # eliminate trailing newline characters if line . endswith ( \" \\n \" ): line = line [: - 1 ] if self . _CONT_RE . match ( line ) or self . _CONC_RE . match ( line ): assert i > 0 # the logic in the below else statement should only be executed once per series of CONT/CONCs. So, # skip is set to True on the first CONT/CONC found and it is handled. Then it is re-set to False # upon detecting the next line that does not contain a CONT/CONC tag if skip : pass else : prev_line = ret [ - 1 ] skip = True if len ( prev_line ) > GEDCOM_MAX_LINE_LENGTH - len ( self . _MISSING_DATA_PLACEHOLDER ): # cut off the previous line so that the missing data placeholder can fit, then append the missing data placeholder ret [ - 1 ] = f \" { prev_line [: GEDCOM_MAX_LINE_LENGTH - len ( self . _MISSING_DATA_PLACEHOLDER )] }{ self . _MISSING_DATA_PLACEHOLDER } \" elif self . _EMPTY_LINE_RE . match ( prev_line ): # Add the missing data placeholder, but make sure there is a space between it and the tag prev_line = f \" { prev_line } { self . _MISSING_DATA_PLACEHOLDER } \" else : # Add the missing data placeholder prev_line = f \" { prev_line }{ self . _MISSING_DATA_PLACEHOLDER } \" else : skip = False ret . append ( line ) if self . ENTRY_DEBUG : print ( \"REMOVE_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret to_col_name_dict ( self ) Transform lines into a CSV-file-friendly dictionary of col-title:value pairs Tags are folded into eachother so that one entry can occupy a single row of the CSV file. E.g. 0 @I42@ INDI 1 NAME Leonard Frank /Bartos/ 2 GIVN Leonard Frank 2 NSFX RPh 1 SEX M 1 _UID 4EF44217DF0F40419968D80B5CC5FE8491FB becomes { \"type\": \"INDI\", \"id:\" @I42@\", \"NAME\": \"Leonard Frand /Bartos/\", \"NAME+GIVN\": \"Leonard Frank\", \"NAME+NSFX\": \"RPh\", \"SEX\": \"M\", \"_UID\": \"4EF44217DF0F40419968D80B5CC5FE8491FB\", } Source code in parsers/entry.py def to_col_name_dict ( self ): \"\"\"Transform lines into a CSV-file-friendly dictionary of col-title:value pairs Tags are folded into eachother so that one entry can occupy a single row of the CSV file. E.g. 0 @I42@ INDI 1 NAME Leonard Frank /Bartos/ 2 GIVN Leonard Frank 2 NSFX RPh 1 SEX M 1 _UID 4EF44217DF0F40419968D80B5CC5FE8491FB becomes { \"type\": \"INDI\", \"id:\" @I42@\", \"NAME\": \"Leonard Frand /Bartos/\", \"NAME+GIVN\": \"Leonard Frank\", \"NAME+NSFX\": \"RPh\", \"SEX\": \"M\", \"_UID\": \"4EF44217DF0F40419968D80B5CC5FE8491FB\", } \"\"\" # at minimum, id and type is needed ret = { \"id\" : self . id , \"tag_type\" : self . type } # a stack of active tags. The tags are concatenated together to form column headers active_tags = [] # iterate through the Line objects directly for i , line in enumerate ( self . _lines ): # Pop all no-longer-active tags off of the stack. The current line's depth - 1 # indicates how many of the active tags are still relevant. (The current line contributes # an active tag. Thus, the length of active tags should always equal the depth of the line if line . depth <= len ( active_tags ) + 1 : active_tags = active_tags [: ( line . depth - 1 )] active_tags . append ( line . tag ) # process tag_value. Tags with no value need a placeholder and date tags may need # adjusting depending on force_string_dates if line . tag_value is None : tag_value = self . _EMPTY_LINE_PLACEHOLDER elif ( line . tag == self . _DATE_TAG and self . force_string_dates and not line . tag . startswith ( \"'\" ) ): tag_value = f \"' { line . tag_value } \" else : tag_value = line . tag_value # Ensure unique column headers. E.g. if there are two NAME entries in a record and each # has a GIVN sub-property, the dictionary should look like: # { # \"NAME+GIVN\": \"value\", # \"NAME+GIVN_1\": \"other value\", # } suffix = 0 while self . _ACTIVE_TAG_SEPARATOR . join ( active_tags ) in ret : suffix += 1 active_tags [ - 1 ] = f \" { line . tag }{ self . _SUFFIX_SEPARATOR }{ suffix } \" ret [ \"+\" . join ( active_tags )] = tag_value if self . ENTRY_DEBUG : print ( \"--ENTRY AS DICT--\" ) for k , v in ret . items (): print ( f \" \\t { k } : { v } \" ) return ret Line Source code in parsers/entry.py class Line : _LINE_RE = re . compile ( r \"^(?P<depth>[0-9]+) (?P<tag>[0-9A-Z_]+)(?: (?P<tag_value>.*))?$\" ) \"\"\"Represents a single line of a gedcom file A line has three parts: depth, tag, and tag_value. The third, tag_value, is optional. The format of a line is: {depth} {tag}[ {tag_value}] Seome examples are: 0 INDI @Ixxx@ 1 DEAT 2 DATE 1876 \"\"\" def __init__ ( self , depth : Union [ str , int ], tag : str , tag_value : Optional [ str ] = None ): r \"\"\" Parameters ---------- depth: Union[str, int] The depth of the gedcom file line. Depth is the first part of a line entry. Typically a single digit 0-3 tag: str The tag of the gedcome file line. E.g. \"NAME\", \"BIRT\", or \"_PLAC\" tag_value: Optional[str], default: None The value corresponding to the tag. E.g. \"John \\Cleese\\\" \"\"\" self . depth = depth self . tag = tag self . tag_value = tag_value @staticmethod def get_parts_from_line ( line : str ) -> dict : r \"\"\"Accepts a gedcome line, parses its constituent parts and returns them as a dictionary Parameters ---------- line: str Returns ------- dict with keys \"depth\", \"tag\", and \"tag_value\". All values in the dict are strings, though \"tag_value\" may have a value of None. \"\"\" m = Line . _LINE_RE . match ( line ) if not m : raise ValueError ( f \"Invalid gedcom line recieved: { line } \" ) return m . groupdict () @classmethod def from_str ( cls , line : str ): \"\"\"Accepts a string and returns a Line object\"\"\" return cls ( ** cls . get_parts_from_line ( line )) def to_str ( self ) -> str : \"\"\"Converts a line object to a string\"\"\" ret = f \" { self . depth } { self . tag } \" if self . tag_value is not None : ret = f \" { ret } { self . tag_value } \" return ret @staticmethod def get_depth_from_line ( line : str ) -> str : \"\"\"Returns the depth value from a gedcom file line. E.g. A NAME line may look like '1 NAME Leonard Frank /Bartos/'. Here the depth is 1, meaning this is a first-order property of a base entry. E.g. A SURN line may look like '2 GIVN Leonard Frank'. Here the depth is 2, meaning this is a second-order property of a base entry (a first-order property of a NAME line, probably). \"\"\" return Line . get_parts_from_line ( line = line )[ \"depth\" ] @staticmethod def get_tag_from_line ( line : str ) -> str : \"\"\"Returns the tag name from a gedcom file line. E.g. 'NAME', 'BIRT', 'FAMS'\"\"\" return Line . get_parts_from_line ( line = line )[ \"tag\" ] @staticmethod def get_tag_value_from_line ( line : str ) -> str : \"\"\"Returns the value associated with a line in a gedcom file. If the line has no value, None is returned E.g. the line '1 NAME Dorothy Adela /Popp/` returns 'Dorothy Adela /Popp/` E.g. the line '1 BIRT' returns None \"\"\" return Line . get_parts_from_line ( line = line )[ \"tag_value\" ] @property def line ( self ): return self . _line @line . setter def line ( self , val ): if not isinstance ( val , str ): raise ValueError ( f \"invalid line type of { type ( val ) } \" ) else : self . _line = val @property def depth ( self ): return self . _depth @depth . setter def depth ( self , val ): if not isinstance ( val , ( str , int )): raise ValueError ( f \"invalid depth type of { type ( val ) } \" ) else : self . _depth = int ( val ) @property def tag ( self ): return self . _tag @tag . setter def tag ( self , val ): if not isinstance ( val , str ): raise ValueError ( f \"invalid tag type of { type ( val ) } \" ) else : self . _tag = val @property def tag_value ( self ): return self . _tag_value @tag_value . setter def tag_value ( self , val ): if val is not None and not isinstance ( val , str ): raise ValueError ( f \"invalid tag_value type of { type ( val ) } \" ) else : self . _tag_value = val __init__ ( self , depth , tag , tag_value = None ) special Parameters !!! depth \"Union[str, int]\" The depth of the gedcom file line. Depth is the first part of a line entry. Typically a single digit 0-3 !!! tag \"str\" The tag of the gedcome file line. E.g. \"NAME\", \"BIRT\", or \"_PLAC\" !!! tag_value \"Optional[str], default: None\" The value corresponding to the tag. E.g. \"John \\Cleese\\\" Source code in parsers/entry.py def __init__ ( self , depth : Union [ str , int ], tag : str , tag_value : Optional [ str ] = None ): r \"\"\" Parameters ---------- depth: Union[str, int] The depth of the gedcom file line. Depth is the first part of a line entry. Typically a single digit 0-3 tag: str The tag of the gedcome file line. E.g. \"NAME\", \"BIRT\", or \"_PLAC\" tag_value: Optional[str], default: None The value corresponding to the tag. E.g. \"John \\Cleese\\\" \"\"\" self . depth = depth self . tag = tag self . tag_value = tag_value from_str ( line ) classmethod Accepts a string and returns a Line object Source code in parsers/entry.py @classmethod def from_str ( cls , line : str ): \"\"\"Accepts a string and returns a Line object\"\"\" return cls ( ** cls . get_parts_from_line ( line )) get_depth_from_line ( line ) staticmethod Returns the depth value from a gedcom file line. E.g. A NAME line may look like '1 NAME Leonard Frank /Bartos/'. Here the depth is 1, meaning this is a first-order property of a base entry. E.g. A SURN line may look like '2 GIVN Leonard Frank'. Here the depth is 2, meaning this is a second-order property of a base entry (a first-order property of a NAME line, probably). Source code in parsers/entry.py @staticmethod def get_depth_from_line ( line : str ) -> str : \"\"\"Returns the depth value from a gedcom file line. E.g. A NAME line may look like '1 NAME Leonard Frank /Bartos/'. Here the depth is 1, meaning this is a first-order property of a base entry. E.g. A SURN line may look like '2 GIVN Leonard Frank'. Here the depth is 2, meaning this is a second-order property of a base entry (a first-order property of a NAME line, probably). \"\"\" return Line . get_parts_from_line ( line = line )[ \"depth\" ] get_parts_from_line ( line ) staticmethod Accepts a gedcome line, parses its constituent parts and returns them as a dictionary Parameters line: str Returns dict with keys \"depth\", \"tag\", and \"tag_value\". All values in the dict are strings, though \"tag_value\" may have a value of None. Source code in parsers/entry.py @staticmethod def get_parts_from_line ( line : str ) -> dict : r \"\"\"Accepts a gedcome line, parses its constituent parts and returns them as a dictionary Parameters ---------- line: str Returns ------- dict with keys \"depth\", \"tag\", and \"tag_value\". All values in the dict are strings, though \"tag_value\" may have a value of None. \"\"\" m = Line . _LINE_RE . match ( line ) if not m : raise ValueError ( f \"Invalid gedcom line recieved: { line } \" ) return m . groupdict () get_tag_from_line ( line ) staticmethod Returns the tag name from a gedcom file line. E.g. 'NAME', 'BIRT', 'FAMS' Source code in parsers/entry.py @staticmethod def get_tag_from_line ( line : str ) -> str : \"\"\"Returns the tag name from a gedcom file line. E.g. 'NAME', 'BIRT', 'FAMS'\"\"\" return Line . get_parts_from_line ( line = line )[ \"tag\" ] get_tag_value_from_line ( line ) staticmethod Returns the value associated with a line in a gedcom file. If the line has no value, None is returned E.g. the line '1 NAME Dorothy Adela /Popp/ returns 'Dorothy Adela /Popp/ E.g. the line '1 BIRT' returns None Source code in parsers/entry.py @staticmethod def get_tag_value_from_line ( line : str ) -> str : \"\"\"Returns the value associated with a line in a gedcom file. If the line has no value, None is returned E.g. the line '1 NAME Dorothy Adela /Popp/` returns 'Dorothy Adela /Popp/` E.g. the line '1 BIRT' returns None \"\"\" return Line . get_parts_from_line ( line = line )[ \"tag_value\" ] to_str ( self ) Converts a line object to a string Source code in parsers/entry.py def to_str ( self ) -> str : \"\"\"Converts a line object to a string\"\"\" ret = f \" { self . depth } { self . tag } \" if self . tag_value is not None : ret = f \" { ret } { self . tag_value } \" return ret gedcom_file Contains the GedcomFile class which is the main entry point for parsing a .ged file GedcomFile Represents the contents of a Gedcom file. Takes the contents of a gedcom file and provides an interface for interpreting the contents and converting each section to CSV format. Parameters gedcom_str : str The contents of a GEDCOM file as a string no_cont_conc : bool Whether or not to preserve data from CONT (continue) and CONC (concatenate) tags in the gedcom file force_string_dates : bool Date values are prepended with a single quote mark (\"'\") if True. This helps render dates as strings in Microsoft Excel, e.g. Methods get_all_records_csv(encoding=\"utf-8\") Returns a dictionary of CSV format strings. Keys are \"INDI\", \"FAM\", and \"SOUR\". get_section_records_csv(section, encoding=\"utf-8\") Returns the individual records formatted as a CSV Source code in parsers/gedcom_file.py class GedcomFile : \"\"\"Represents the contents of a Gedcom file. Takes the contents of a gedcom file and provides an interface for interpreting the contents and converting each section to CSV format. Parameters ---------- gedcom_str : str The contents of a GEDCOM file as a string no_cont_conc : bool Whether or not to preserve data from CONT (continue) and CONC (concatenate) tags in the gedcom file force_string_dates : bool Date values are prepended with a single quote mark (\"'\") if True. This helps render dates as strings in Microsoft Excel, e.g. Methods ------- get_all_records_csv(encoding=\"utf-8\") Returns a dictionary of CSV format strings. Keys are \"INDI\", \"FAM\", and \"SOUR\". get_section_records_csv(section, encoding=\"utf-8\") Returns the individual records formatted as a CSV \"\"\" def __init__ ( self , gedcom_str : str , no_cont_conc : bool , force_string_dates : bool , ) -> None : self . gedcom_lines = gedcom_str . split ( \" \\n \" ) self . no_cont_conc = no_cont_conc self . force_string_dates = force_string_dates def get_all_records_csv ( self , encoding : str = \"utf-8\" ) -> Dict [ str , str ]: \"\"\"Converts gedcom_str into separate CSV strings for indi, fam, and sour records Parameters ---------- encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- Dict[str, str] A dictionary of entry type to csv strings with the following keys: - \"INDI\": individual entries csv string, - \"FAM\": family entries csv string, - \"SOUR\": source entries csv string, \"\"\" return { \"INDI\" : self . get_section_records_csv ( section = \"indi\" , encoding = encoding ), \"FAM\" : self . get_section_records_csv ( section = \"fam\" , encoding = encoding ), \"SOUR\" : self . get_section_records_csv ( section = \"sour\" , encoding = encoding ), } def get_section_records_csv ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ], encoding : str = \"utf-8\" ) -> str : \"\"\"Returns the records of a type as a CSV formatted string Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section-type to convert to CSV and return encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- str \"\"\" entries = self . _get_section_entries ( section = section ) df = self . _get_entries_df ( entries = entries ) return self . _convert_df_to_csv ( df = df , encoding = encoding ) def _get_entries_df ( self , entries : List [ Entry ]) -> pd . DataFrame : \"\"\"Converts a list of entries into a pandas DataFrame object Parameters ---------- entries : List[Entry] Returns ------- pd.DataFrame \"\"\" return pd . DataFrame ( x . to_col_name_dict () for x in entries ) def _convert_df_to_csv ( self , df : pd . DataFrame , encoding : str = \"utf-8\" ) -> str : \"\"\"Accepts a dataframe and returns it formatted as a CSV string Parameters ---------- df : pd.DataFrame encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- str A CSV-formatted string with the contents of df \"\"\" return df . to_csv ( header = True , index = False , encoding = encoding ) def _get_section_entries ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ]) -> List [ Entry ]: \"\"\"Parses a section of the gedcom string and instantiates Entry items for the section Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section of the gedcom string to process Returns ------- List[Entry] A list of Entry objects, one for each primary 0-level entry in the given section Raises ------ RuntimeError if the section boundaries cannot be determined from the gedcom file. This indicates a mal-formed gedcom file. \"\"\" ret = [] start_line_index = self . _get_section_start_index ( section = section ) end_line_index = self . _get_section_end_index ( section = section ) if ( start_line_index is None ) ^ ( end_line_index is None ): raise RuntimeError ( f \"Cannot determine boundaries of { section } in the provided gedcom string. \\n \" \" Ensure that the GEDCOM file is formatted correctly and try again.\" ) elif start_line_index : assert end_line_index is not None i = start_line_index while i <= end_line_index : j = i + 1 while j < len ( self . gedcom_lines ) and not self . gedcom_lines [ j ] . startswith ( \"0\" ): j += 1 assert j <= end_line_index + 1 assert self . gedcom_lines [ i ] . startswith ( \"0\" ) assert self . gedcom_lines [ j ] . startswith ( \"0\" ) LOG . debug ( f \"RECORD LINES { i } - { j } :\" ) for k in range ( i , j ): LOG . debug ( f \" \\t { self . gedcom_lines [ k ] } \" ) ret . append ( Entry ( lines = self . gedcom_lines [ i : j ], force_string_dates = self . force_string_dates , no_cont_conc = self . no_cont_conc , ) ) i = j return ret def _get_section_start_index ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ]) -> Union [ int , None ]: \"\"\"Returns the section start line index Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section to seek the beginning of Returns ------- Union[int, None] The line index (zero-indexed) of the gedcom string that marks the beginning of the requested section. If None is returned, this indicates the section is absent from the gedcom file \"\"\" pattern = self . _get_entry_regex_pattern ( section = section ) # find first instance of match ret = None for i , line in enumerate ( self . gedcom_lines ): if pattern . match ( line ): ret = i break LOG . debug ( f \"Start index of { section } determined: { ret } \" ) return ret def _get_section_end_index ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ]) -> int : \"\"\"Returns the section end line index Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section to seek the end of Returns ------- Union[int, None] The line index (zero-indexed) of the gedcom string that marks the end of the requested section. If None is returned, this indicates the section is absent from the gedcom file \"\"\" pattern = self . _get_entry_regex_pattern ( section = section ) ret = None i = len ( self . gedcom_lines ) - 1 # start from the end of the gedcom file and work backwards searching for the last line that # matches the provided entry pattern end_found = False while i > 0 and not end_found : if pattern . match ( self . gedcom_lines [ i ]): end_found = True i += 1 # Now start working back forwards to find the end of this indi entry while i < len ( self . gedcom_lines ) and not self . gedcom_lines [ i ] . startswith ( \"0\" ): i += 1 if self . gedcom_lines [ i ] . startswith ( \"0\" ): ret = i - 1 i -= 1 LOG . debug ( f \"End index of { section } determined: { ret } \" ) return ret def _get_entry_regex_pattern ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ]) -> Pattern : \"\"\"Returns a compiled regex pattern for matching 0-level entries for the given section type Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Returns ------- Pattern a compiled regex pattern that will match 0-level entries of the requested type Raises ------ ValueError if the provided section value does not match one of the available patterns \"\"\" if section == \"indi\" : ret = _INDI_REGEX elif section == \"fam\" : ret = _FAM_REGEX elif section == \"sour\" : ret = _SOUR_REGEX else : raise ValueError ( f \"invalid section type ' { section } ' provided\" ) return ret get_all_records_csv ( self , encoding = 'utf-8' ) Converts gedcom_str into separate CSV strings for indi, fam, and sour records Parameters encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns Dict[str, str] A dictionary of entry type to csv strings with the following keys: - \"INDI\": individual entries csv string, - \"FAM\": family entries csv string, - \"SOUR\": source entries csv string, Source code in parsers/gedcom_file.py def get_all_records_csv ( self , encoding : str = \"utf-8\" ) -> Dict [ str , str ]: \"\"\"Converts gedcom_str into separate CSV strings for indi, fam, and sour records Parameters ---------- encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- Dict[str, str] A dictionary of entry type to csv strings with the following keys: - \"INDI\": individual entries csv string, - \"FAM\": family entries csv string, - \"SOUR\": source entries csv string, \"\"\" return { \"INDI\" : self . get_section_records_csv ( section = \"indi\" , encoding = encoding ), \"FAM\" : self . get_section_records_csv ( section = \"fam\" , encoding = encoding ), \"SOUR\" : self . get_section_records_csv ( section = \"sour\" , encoding = encoding ), } get_section_records_csv ( self , section , encoding = 'utf-8' ) Returns the records of a type as a CSV formatted string Parameters section : Literal[\"indi\", \"fam\", \"sour\"] Which section-type to convert to CSV and return encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns str Source code in parsers/gedcom_file.py def get_section_records_csv ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ], encoding : str = \"utf-8\" ) -> str : \"\"\"Returns the records of a type as a CSV formatted string Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section-type to convert to CSV and return encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- str \"\"\" entries = self . _get_section_entries ( section = section ) df = self . _get_entries_df ( entries = entries ) return self . _convert_df_to_csv ( df = df , encoding = encoding )","title":"Index"},{"location":"reference/parsers/#parsers.entry","text":"Entry!!!","title":"entry"},{"location":"reference/parsers/#parsers.entry.Entry","text":"Class to manage an entry. Where an entry is an entire INDI, FAM, or SOUR entry in a gedcom file Source code in parsers/entry.py class Entry : \"\"\"Class to manage an entry. Where an entry is an entire INDI, FAM, or SOUR entry in a gedcom file\"\"\" _EMPTY_LINE_PLACEHOLDER = \"<<NONE>>\" _CONT_PLACEHOLDER = \"<<CONT>>\" _MISSING_DATA_PLACEHOLDER = \"<<MISSING DATA>>\" _CONT_RE = re . compile ( \"^\\d+ CONT (?P<value>.*)\" ) _CONC_RE = re . compile ( \"^\\d+ CONC (?P<value>.*)\" ) _EMPTY_LINE_RE = re . compile ( r \"^\\d+ [A-Z_]{3,5}$\" ) _FIRST_LINE_RE = re . compile ( r \"^0 (?P<id>@[IFS]\\d+@) (?P<type>(?:INDI|FAM|SOUR))$\" ) _DATE_TAG = \"DATE\" _ACTIVE_TAG_SEPARATOR = \"+\" _SUFFIX_SEPARATOR = \"~\" def __init__ ( self , lines : List [ str ], force_string_dates : bool , no_cont_conc : bool ) -> None : f \"\"\" Parameters ---------- lines: List[str] A list of strings where each item in the list is a line of a gedcome file pertaining to the entry. The order is assumed to be top -> bottom as if reading the gedcom file force_string_dates: bool A flag that, when True, will add a single-quote (') in front of DATE values. This should force excel to render these values as strings rather than attempt to interpret them as dates. Which it isn't super good at. no_cont_conc: bool A flag that, when True, disables attempts to preserve all CONT and CONC data. Instead a missing data string is put in place of CONT and CONC continued/concatenated values. \"\"\" # the first line is not like the others. It contians the type of entry, and the id number self . ENTRY_DEBUG = env ( \"VERBOSE_OUTPUT\" , cast = bool , default = False ) # set self.id and self.type for k , v in self . get_first_line_dict ( lines [ 0 ]) . items (): setattr ( self , k , v ) self . force_string_dates = force_string_dates self . no_cont_conc = no_cont_conc self . lines = lines [ 1 :] @staticmethod def get_first_line_dict ( line ) -> dict : \"\"\"Parses the first line of an entry and returns a dict with the groups defined in _FIRST_LINE_RE\"\"\" match = Entry . _FIRST_LINE_RE . match ( line ) assert match return match . groupdict () @property def lines ( self ) -> List [ str ]: \"\"\"Returns self.lines as a list of strings\"\"\" return self . add_cont_conc ([ l . to_str () for l in self . _lines ]) @lines . setter def lines ( self , val ) -> None : \"\"\"Sets self.lines. Stores lines as line objects under the hood\"\"\" if not isinstance ( val , list ): raise ValueError ( f \"lines must be an instance of list, go { type ( val ) } \" ) elif not all ([ isinstance ( v , str ) for v in val ]): raise ValueError ( \"All lines must be string values\" ) else : if self . no_cont_conc : self . _lines = [ Line . from_str ( l ) for l in self . remove_cont_conc ( val )] else : self . _lines = [ Line . from_str ( l ) for l in self . collapse_cont_conc ( val )] def remove_cont_conc ( self , lines : List [ str ]) -> List [ str ]: r \"\"\"Removes CONT and CONC tags from a list of lines. Replaces them with a warning string Parameters ---------- lines: List[str] A list of gedcom file lines Returns ------- List[str] The processed gedcome file lines with CONT and CONC tags removed Example ------- Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long<<MISSING DATA>>\"] \"\"\" ret = [] skip = False for i , line in enumerate ( lines ): # eliminate trailing newline characters if line . endswith ( \" \\n \" ): line = line [: - 1 ] if self . _CONT_RE . match ( line ) or self . _CONC_RE . match ( line ): assert i > 0 # the logic in the below else statement should only be executed once per series of CONT/CONCs. So, # skip is set to True on the first CONT/CONC found and it is handled. Then it is re-set to False # upon detecting the next line that does not contain a CONT/CONC tag if skip : pass else : prev_line = ret [ - 1 ] skip = True if len ( prev_line ) > GEDCOM_MAX_LINE_LENGTH - len ( self . _MISSING_DATA_PLACEHOLDER ): # cut off the previous line so that the missing data placeholder can fit, then append the missing data placeholder ret [ - 1 ] = f \" { prev_line [: GEDCOM_MAX_LINE_LENGTH - len ( self . _MISSING_DATA_PLACEHOLDER )] }{ self . _MISSING_DATA_PLACEHOLDER } \" elif self . _EMPTY_LINE_RE . match ( prev_line ): # Add the missing data placeholder, but make sure there is a space between it and the tag prev_line = f \" { prev_line } { self . _MISSING_DATA_PLACEHOLDER } \" else : # Add the missing data placeholder prev_line = f \" { prev_line }{ self . _MISSING_DATA_PLACEHOLDER } \" else : skip = False ret . append ( line ) if self . ENTRY_DEBUG : print ( \"REMOVE_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret def collapse_cont_conc ( self , lines : List [ str ]) -> List [ str ]: r \"\"\"Accepts a list of strings, combines lines that are contineud via CONT/CONC. Returns the modified list Parameters ---------- lines: List[str] A list of gedcom file lines Returns ------- List[str] The processed gedcome file lines with CONT and CONC folded up into the lines that they continued/concatenated Example ------- Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long<<CONT>>long long long long long long note\"] \"\"\" \"\"\"Removes CONT and CONC tags in a list of lines by combining those lines into one line\"\"\" ret = [] for i , line in enumerate ( lines ): # remove errant trailing newline characters if line . endswith ( \" \\n \" ): line = line [: - 1 ] cont_match = self . _CONT_RE . match ( line ) conc_match = self . _CONC_RE . match ( line ) assert not ( cont_match and conc_match ) if cont_match : assert i != 0 if self . _EMPTY_LINE_RE . match ( ret [ - 1 ]): # if ret[-1] is nothing but a depth and tag, there needs to be a space before the CONT ret [ - 1 ] = f \" { ret [ - 1 ] } { self . _CONT_PLACEHOLDER }{ cont_match . groupdict ()[ 'value' ] } \" else : ret [ - 1 ] = f \" { ret [ - 1 ] }{ self . _CONT_PLACEHOLDER }{ cont_match . groupdict ()[ 'value' ] } \" elif conc_match : assert i != 0 assert not self . _EMPTY_LINE_RE . match ( ret [ - 1 ]) # simply append the concatenated value. No need to check for empty tags as by definition, conc # tags are not applied to empty lines ret [ - 1 ] = f \" { ret [ - 1 ] }{ conc_match . groupdict ()[ 'value' ] } \" else : # no processing necessary. Just append and move on ret . append ( line ) if self . ENTRY_DEBUG : print ( \"COLLAPSE_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret @staticmethod def add_cont_conc ( lines : List [ str ]) -> List [ str ]: def get_tag_value_chunk ( depth : Union [ int , str ], tag : str , tag_value : str ): \"\"\"Helper function to determine when and how to split a tag value Parameters ---------- depth: Union[int, str] the depth value for the line being examined tag: str the tag for the line being examined. E.g. DATE, PLAC or BURI tag_value: str the rest of the line being examined Returns ------- Tuple[bool, str, str, Union[str, None]] [0] - boolean: whether the tag_value needed to be split or not [1] - str: The tag for this line. Original tag, CONC, or CONT [2] - str: the value of the split-off section of tag_value [3] - str|None: the remainder of tag_value \"\"\" ret = ( False , tag , tag_value , None ) if tag_value is not None : len_depth = len ( str ( depth )) len_tag = len ( tag ) len_tag_value = len ( tag_value ) num_spaces = 2 if ( len_depth + len_tag + len_tag_value + num_spaces > GEDCOM_MAX_LINE_LENGTH or tag_value . find ( Entry . _CONT_PLACEHOLDER ) != - 1 ): newline_index = tag_value . find ( Entry . _CONT_PLACEHOLDER ) if newline_index != - 1 : if ( len_depth + len_tag + num_spaces + newline_index ) < GEDCOM_MAX_LINE_LENGTH : ret = ( True , \"CONT\" , tag_value . split ( Entry . _CONT_PLACEHOLDER )[ 0 ], Entry . _CONT_PLACEHOLDER . join ( tag_value . split ( Entry . _CONT_PLACEHOLDER )[ 1 :] ), ) else : ret = ( True , \"CONC\" , tag_value [ : GEDCOM_MAX_LINE_LENGTH - 1 - len_depth - len_tag - num_spaces ], tag_value [ GEDCOM_MAX_LINE_LENGTH - 1 - len_depth - len_tag - num_spaces : ], ) else : ret = ( True , \"CONC\" , tag_value [: GEDCOM_MAX_LINE_LENGTH - len_depth - len_tag - num_spaces ], tag_value [ GEDCOM_MAX_LINE_LENGTH - len_depth - len_tag - num_spaces :], ) else : pass else : pass return ret if env ( \"VERBOSE_OUTPUT\" , cast = bool , default = False ): print ( \"ADD_CONT_CONC input:\" ) for x in lines : print ( f \" \\t { x } \" ) ret = [] for i , line in enumerate ( lines ): depth = int ( Line . get_depth_from_line ( line )) tag = Line . get_tag_from_line ( line ) tag_value = Line . get_tag_value_from_line ( line ) need_split , new_tag , tag_value , next_tag_value = get_tag_value_chunk ( depth , tag , tag_value ) ret . append ( f \" { depth } { tag } { tag_value } \" ) while need_split : ( need_split , new_tag , prev_tag_value , next_tag_value ) = get_tag_value_chunk ( depth + 1 , new_tag , next_tag_value ) if prev_tag_value : ret . append ( f \" { depth + 1 } { new_tag } { prev_tag_value } \" ) else : ret . append ( f \" { depth + 1 } { new_tag } \" ) if env ( \"VERBOSE_OUTPUT\" , cast = bool , default = False ): print ( \"ADD_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret def to_col_name_dict ( self ): \"\"\"Transform lines into a CSV-file-friendly dictionary of col-title:value pairs Tags are folded into eachother so that one entry can occupy a single row of the CSV file. E.g. 0 @I42@ INDI 1 NAME Leonard Frank /Bartos/ 2 GIVN Leonard Frank 2 NSFX RPh 1 SEX M 1 _UID 4EF44217DF0F40419968D80B5CC5FE8491FB becomes { \"type\": \"INDI\", \"id:\" @I42@\", \"NAME\": \"Leonard Frand /Bartos/\", \"NAME+GIVN\": \"Leonard Frank\", \"NAME+NSFX\": \"RPh\", \"SEX\": \"M\", \"_UID\": \"4EF44217DF0F40419968D80B5CC5FE8491FB\", } \"\"\" # at minimum, id and type is needed ret = { \"id\" : self . id , \"tag_type\" : self . type } # a stack of active tags. The tags are concatenated together to form column headers active_tags = [] # iterate through the Line objects directly for i , line in enumerate ( self . _lines ): # Pop all no-longer-active tags off of the stack. The current line's depth - 1 # indicates how many of the active tags are still relevant. (The current line contributes # an active tag. Thus, the length of active tags should always equal the depth of the line if line . depth <= len ( active_tags ) + 1 : active_tags = active_tags [: ( line . depth - 1 )] active_tags . append ( line . tag ) # process tag_value. Tags with no value need a placeholder and date tags may need # adjusting depending on force_string_dates if line . tag_value is None : tag_value = self . _EMPTY_LINE_PLACEHOLDER elif ( line . tag == self . _DATE_TAG and self . force_string_dates and not line . tag . startswith ( \"'\" ) ): tag_value = f \"' { line . tag_value } \" else : tag_value = line . tag_value # Ensure unique column headers. E.g. if there are two NAME entries in a record and each # has a GIVN sub-property, the dictionary should look like: # { # \"NAME+GIVN\": \"value\", # \"NAME+GIVN_1\": \"other value\", # } suffix = 0 while self . _ACTIVE_TAG_SEPARATOR . join ( active_tags ) in ret : suffix += 1 active_tags [ - 1 ] = f \" { line . tag }{ self . _SUFFIX_SEPARATOR }{ suffix } \" ret [ \"+\" . join ( active_tags )] = tag_value if self . ENTRY_DEBUG : print ( \"--ENTRY AS DICT--\" ) for k , v in ret . items (): print ( f \" \\t { k } : { v } \" ) return ret","title":"Entry"},{"location":"reference/parsers/#parsers.entry.Entry.lines","text":"Returns self.lines as a list of strings","title":"lines"},{"location":"reference/parsers/#parsers.entry.Entry.collapse_cont_conc","text":"Accepts a list of strings, combines lines that are contineud via CONT/CONC. Returns the modified list","title":"collapse_cont_conc()"},{"location":"reference/parsers/#parsers.entry.Entry.collapse_cont_conc--parameters","text":"!!! lines \"List[str]\" A list of gedcom file lines","title":"Parameters"},{"location":"reference/parsers/#parsers.entry.Entry.collapse_cont_conc--returns","text":"List[str] The processed gedcome file lines with CONT and CONC folded up into the lines that they continued/concatenated","title":"Returns"},{"location":"reference/parsers/#parsers.entry.Entry.collapse_cont_conc--example","text":"Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long< >long long long long long long note\"] Source code in parsers/entry.py def collapse_cont_conc ( self , lines : List [ str ]) -> List [ str ]: r \"\"\"Accepts a list of strings, combines lines that are contineud via CONT/CONC. Returns the modified list Parameters ---------- lines: List[str] A list of gedcom file lines Returns ------- List[str] The processed gedcome file lines with CONT and CONC folded up into the lines that they continued/concatenated Example ------- Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long<<CONT>>long long long long long long note\"] \"\"\" \"\"\"Removes CONT and CONC tags in a list of lines by combining those lines into one line\"\"\" ret = [] for i , line in enumerate ( lines ): # remove errant trailing newline characters if line . endswith ( \" \\n \" ): line = line [: - 1 ] cont_match = self . _CONT_RE . match ( line ) conc_match = self . _CONC_RE . match ( line ) assert not ( cont_match and conc_match ) if cont_match : assert i != 0 if self . _EMPTY_LINE_RE . match ( ret [ - 1 ]): # if ret[-1] is nothing but a depth and tag, there needs to be a space before the CONT ret [ - 1 ] = f \" { ret [ - 1 ] } { self . _CONT_PLACEHOLDER }{ cont_match . groupdict ()[ 'value' ] } \" else : ret [ - 1 ] = f \" { ret [ - 1 ] }{ self . _CONT_PLACEHOLDER }{ cont_match . groupdict ()[ 'value' ] } \" elif conc_match : assert i != 0 assert not self . _EMPTY_LINE_RE . match ( ret [ - 1 ]) # simply append the concatenated value. No need to check for empty tags as by definition, conc # tags are not applied to empty lines ret [ - 1 ] = f \" { ret [ - 1 ] }{ conc_match . groupdict ()[ 'value' ] } \" else : # no processing necessary. Just append and move on ret . append ( line ) if self . ENTRY_DEBUG : print ( \"COLLAPSE_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret","title":"Example"},{"location":"reference/parsers/#parsers.entry.Entry.get_first_line_dict","text":"Parses the first line of an entry and returns a dict with the groups defined in _FIRST_LINE_RE Source code in parsers/entry.py @staticmethod def get_first_line_dict ( line ) -> dict : \"\"\"Parses the first line of an entry and returns a dict with the groups defined in _FIRST_LINE_RE\"\"\" match = Entry . _FIRST_LINE_RE . match ( line ) assert match return match . groupdict ()","title":"get_first_line_dict()"},{"location":"reference/parsers/#parsers.entry.Entry.remove_cont_conc","text":"Removes CONT and CONC tags from a list of lines. Replaces them with a warning string","title":"remove_cont_conc()"},{"location":"reference/parsers/#parsers.entry.Entry.remove_cont_conc--parameters","text":"!!! lines \"List[str]\" A list of gedcom file lines","title":"Parameters"},{"location":"reference/parsers/#parsers.entry.Entry.remove_cont_conc--returns","text":"List[str] The processed gedcome file lines with CONT and CONC tags removed","title":"Returns"},{"location":"reference/parsers/#parsers.entry.Entry.remove_cont_conc--example","text":"Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long< >\"] Source code in parsers/entry.py def remove_cont_conc ( self , lines : List [ str ]) -> List [ str ]: r \"\"\"Removes CONT and CONC tags from a list of lines. Replaces them with a warning string Parameters ---------- lines: List[str] A list of gedcom file lines Returns ------- List[str] The processed gedcome file lines with CONT and CONC tags removed Example ------- Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long<<MISSING DATA>>\"] \"\"\" ret = [] skip = False for i , line in enumerate ( lines ): # eliminate trailing newline characters if line . endswith ( \" \\n \" ): line = line [: - 1 ] if self . _CONT_RE . match ( line ) or self . _CONC_RE . match ( line ): assert i > 0 # the logic in the below else statement should only be executed once per series of CONT/CONCs. So, # skip is set to True on the first CONT/CONC found and it is handled. Then it is re-set to False # upon detecting the next line that does not contain a CONT/CONC tag if skip : pass else : prev_line = ret [ - 1 ] skip = True if len ( prev_line ) > GEDCOM_MAX_LINE_LENGTH - len ( self . _MISSING_DATA_PLACEHOLDER ): # cut off the previous line so that the missing data placeholder can fit, then append the missing data placeholder ret [ - 1 ] = f \" { prev_line [: GEDCOM_MAX_LINE_LENGTH - len ( self . _MISSING_DATA_PLACEHOLDER )] }{ self . _MISSING_DATA_PLACEHOLDER } \" elif self . _EMPTY_LINE_RE . match ( prev_line ): # Add the missing data placeholder, but make sure there is a space between it and the tag prev_line = f \" { prev_line } { self . _MISSING_DATA_PLACEHOLDER } \" else : # Add the missing data placeholder prev_line = f \" { prev_line }{ self . _MISSING_DATA_PLACEHOLDER } \" else : skip = False ret . append ( line ) if self . ENTRY_DEBUG : print ( \"REMOVE_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret","title":"Example"},{"location":"reference/parsers/#parsers.entry.Entry.to_col_name_dict","text":"Transform lines into a CSV-file-friendly dictionary of col-title:value pairs Tags are folded into eachother so that one entry can occupy a single row of the CSV file. E.g. 0 @I42@ INDI 1 NAME Leonard Frank /Bartos/ 2 GIVN Leonard Frank 2 NSFX RPh 1 SEX M 1 _UID 4EF44217DF0F40419968D80B5CC5FE8491FB becomes { \"type\": \"INDI\", \"id:\" @I42@\", \"NAME\": \"Leonard Frand /Bartos/\", \"NAME+GIVN\": \"Leonard Frank\", \"NAME+NSFX\": \"RPh\", \"SEX\": \"M\", \"_UID\": \"4EF44217DF0F40419968D80B5CC5FE8491FB\", } Source code in parsers/entry.py def to_col_name_dict ( self ): \"\"\"Transform lines into a CSV-file-friendly dictionary of col-title:value pairs Tags are folded into eachother so that one entry can occupy a single row of the CSV file. E.g. 0 @I42@ INDI 1 NAME Leonard Frank /Bartos/ 2 GIVN Leonard Frank 2 NSFX RPh 1 SEX M 1 _UID 4EF44217DF0F40419968D80B5CC5FE8491FB becomes { \"type\": \"INDI\", \"id:\" @I42@\", \"NAME\": \"Leonard Frand /Bartos/\", \"NAME+GIVN\": \"Leonard Frank\", \"NAME+NSFX\": \"RPh\", \"SEX\": \"M\", \"_UID\": \"4EF44217DF0F40419968D80B5CC5FE8491FB\", } \"\"\" # at minimum, id and type is needed ret = { \"id\" : self . id , \"tag_type\" : self . type } # a stack of active tags. The tags are concatenated together to form column headers active_tags = [] # iterate through the Line objects directly for i , line in enumerate ( self . _lines ): # Pop all no-longer-active tags off of the stack. The current line's depth - 1 # indicates how many of the active tags are still relevant. (The current line contributes # an active tag. Thus, the length of active tags should always equal the depth of the line if line . depth <= len ( active_tags ) + 1 : active_tags = active_tags [: ( line . depth - 1 )] active_tags . append ( line . tag ) # process tag_value. Tags with no value need a placeholder and date tags may need # adjusting depending on force_string_dates if line . tag_value is None : tag_value = self . _EMPTY_LINE_PLACEHOLDER elif ( line . tag == self . _DATE_TAG and self . force_string_dates and not line . tag . startswith ( \"'\" ) ): tag_value = f \"' { line . tag_value } \" else : tag_value = line . tag_value # Ensure unique column headers. E.g. if there are two NAME entries in a record and each # has a GIVN sub-property, the dictionary should look like: # { # \"NAME+GIVN\": \"value\", # \"NAME+GIVN_1\": \"other value\", # } suffix = 0 while self . _ACTIVE_TAG_SEPARATOR . join ( active_tags ) in ret : suffix += 1 active_tags [ - 1 ] = f \" { line . tag }{ self . _SUFFIX_SEPARATOR }{ suffix } \" ret [ \"+\" . join ( active_tags )] = tag_value if self . ENTRY_DEBUG : print ( \"--ENTRY AS DICT--\" ) for k , v in ret . items (): print ( f \" \\t { k } : { v } \" ) return ret","title":"to_col_name_dict()"},{"location":"reference/parsers/#parsers.entry.Line","text":"Source code in parsers/entry.py class Line : _LINE_RE = re . compile ( r \"^(?P<depth>[0-9]+) (?P<tag>[0-9A-Z_]+)(?: (?P<tag_value>.*))?$\" ) \"\"\"Represents a single line of a gedcom file A line has three parts: depth, tag, and tag_value. The third, tag_value, is optional. The format of a line is: {depth} {tag}[ {tag_value}] Seome examples are: 0 INDI @Ixxx@ 1 DEAT 2 DATE 1876 \"\"\" def __init__ ( self , depth : Union [ str , int ], tag : str , tag_value : Optional [ str ] = None ): r \"\"\" Parameters ---------- depth: Union[str, int] The depth of the gedcom file line. Depth is the first part of a line entry. Typically a single digit 0-3 tag: str The tag of the gedcome file line. E.g. \"NAME\", \"BIRT\", or \"_PLAC\" tag_value: Optional[str], default: None The value corresponding to the tag. E.g. \"John \\Cleese\\\" \"\"\" self . depth = depth self . tag = tag self . tag_value = tag_value @staticmethod def get_parts_from_line ( line : str ) -> dict : r \"\"\"Accepts a gedcome line, parses its constituent parts and returns them as a dictionary Parameters ---------- line: str Returns ------- dict with keys \"depth\", \"tag\", and \"tag_value\". All values in the dict are strings, though \"tag_value\" may have a value of None. \"\"\" m = Line . _LINE_RE . match ( line ) if not m : raise ValueError ( f \"Invalid gedcom line recieved: { line } \" ) return m . groupdict () @classmethod def from_str ( cls , line : str ): \"\"\"Accepts a string and returns a Line object\"\"\" return cls ( ** cls . get_parts_from_line ( line )) def to_str ( self ) -> str : \"\"\"Converts a line object to a string\"\"\" ret = f \" { self . depth } { self . tag } \" if self . tag_value is not None : ret = f \" { ret } { self . tag_value } \" return ret @staticmethod def get_depth_from_line ( line : str ) -> str : \"\"\"Returns the depth value from a gedcom file line. E.g. A NAME line may look like '1 NAME Leonard Frank /Bartos/'. Here the depth is 1, meaning this is a first-order property of a base entry. E.g. A SURN line may look like '2 GIVN Leonard Frank'. Here the depth is 2, meaning this is a second-order property of a base entry (a first-order property of a NAME line, probably). \"\"\" return Line . get_parts_from_line ( line = line )[ \"depth\" ] @staticmethod def get_tag_from_line ( line : str ) -> str : \"\"\"Returns the tag name from a gedcom file line. E.g. 'NAME', 'BIRT', 'FAMS'\"\"\" return Line . get_parts_from_line ( line = line )[ \"tag\" ] @staticmethod def get_tag_value_from_line ( line : str ) -> str : \"\"\"Returns the value associated with a line in a gedcom file. If the line has no value, None is returned E.g. the line '1 NAME Dorothy Adela /Popp/` returns 'Dorothy Adela /Popp/` E.g. the line '1 BIRT' returns None \"\"\" return Line . get_parts_from_line ( line = line )[ \"tag_value\" ] @property def line ( self ): return self . _line @line . setter def line ( self , val ): if not isinstance ( val , str ): raise ValueError ( f \"invalid line type of { type ( val ) } \" ) else : self . _line = val @property def depth ( self ): return self . _depth @depth . setter def depth ( self , val ): if not isinstance ( val , ( str , int )): raise ValueError ( f \"invalid depth type of { type ( val ) } \" ) else : self . _depth = int ( val ) @property def tag ( self ): return self . _tag @tag . setter def tag ( self , val ): if not isinstance ( val , str ): raise ValueError ( f \"invalid tag type of { type ( val ) } \" ) else : self . _tag = val @property def tag_value ( self ): return self . _tag_value @tag_value . setter def tag_value ( self , val ): if val is not None and not isinstance ( val , str ): raise ValueError ( f \"invalid tag_value type of { type ( val ) } \" ) else : self . _tag_value = val","title":"Line"},{"location":"reference/parsers/#parsers.entry.Line.__init__","text":"","title":"__init__()"},{"location":"reference/parsers/#parsers.entry.Line.__init__--parameters","text":"!!! depth \"Union[str, int]\" The depth of the gedcom file line. Depth is the first part of a line entry. Typically a single digit 0-3 !!! tag \"str\" The tag of the gedcome file line. E.g. \"NAME\", \"BIRT\", or \"_PLAC\" !!! tag_value \"Optional[str], default: None\" The value corresponding to the tag. E.g. \"John \\Cleese\\\" Source code in parsers/entry.py def __init__ ( self , depth : Union [ str , int ], tag : str , tag_value : Optional [ str ] = None ): r \"\"\" Parameters ---------- depth: Union[str, int] The depth of the gedcom file line. Depth is the first part of a line entry. Typically a single digit 0-3 tag: str The tag of the gedcome file line. E.g. \"NAME\", \"BIRT\", or \"_PLAC\" tag_value: Optional[str], default: None The value corresponding to the tag. E.g. \"John \\Cleese\\\" \"\"\" self . depth = depth self . tag = tag self . tag_value = tag_value","title":"Parameters"},{"location":"reference/parsers/#parsers.entry.Line.from_str","text":"Accepts a string and returns a Line object Source code in parsers/entry.py @classmethod def from_str ( cls , line : str ): \"\"\"Accepts a string and returns a Line object\"\"\" return cls ( ** cls . get_parts_from_line ( line ))","title":"from_str()"},{"location":"reference/parsers/#parsers.entry.Line.get_depth_from_line","text":"Returns the depth value from a gedcom file line. E.g. A NAME line may look like '1 NAME Leonard Frank /Bartos/'. Here the depth is 1, meaning this is a first-order property of a base entry. E.g. A SURN line may look like '2 GIVN Leonard Frank'. Here the depth is 2, meaning this is a second-order property of a base entry (a first-order property of a NAME line, probably). Source code in parsers/entry.py @staticmethod def get_depth_from_line ( line : str ) -> str : \"\"\"Returns the depth value from a gedcom file line. E.g. A NAME line may look like '1 NAME Leonard Frank /Bartos/'. Here the depth is 1, meaning this is a first-order property of a base entry. E.g. A SURN line may look like '2 GIVN Leonard Frank'. Here the depth is 2, meaning this is a second-order property of a base entry (a first-order property of a NAME line, probably). \"\"\" return Line . get_parts_from_line ( line = line )[ \"depth\" ]","title":"get_depth_from_line()"},{"location":"reference/parsers/#parsers.entry.Line.get_parts_from_line","text":"Accepts a gedcome line, parses its constituent parts and returns them as a dictionary","title":"get_parts_from_line()"},{"location":"reference/parsers/#parsers.entry.Line.get_parts_from_line--parameters","text":"line: str","title":"Parameters"},{"location":"reference/parsers/#parsers.entry.Line.get_parts_from_line--returns","text":"dict with keys \"depth\", \"tag\", and \"tag_value\". All values in the dict are strings, though \"tag_value\" may have a value of None. Source code in parsers/entry.py @staticmethod def get_parts_from_line ( line : str ) -> dict : r \"\"\"Accepts a gedcome line, parses its constituent parts and returns them as a dictionary Parameters ---------- line: str Returns ------- dict with keys \"depth\", \"tag\", and \"tag_value\". All values in the dict are strings, though \"tag_value\" may have a value of None. \"\"\" m = Line . _LINE_RE . match ( line ) if not m : raise ValueError ( f \"Invalid gedcom line recieved: { line } \" ) return m . groupdict ()","title":"Returns"},{"location":"reference/parsers/#parsers.entry.Line.get_tag_from_line","text":"Returns the tag name from a gedcom file line. E.g. 'NAME', 'BIRT', 'FAMS' Source code in parsers/entry.py @staticmethod def get_tag_from_line ( line : str ) -> str : \"\"\"Returns the tag name from a gedcom file line. E.g. 'NAME', 'BIRT', 'FAMS'\"\"\" return Line . get_parts_from_line ( line = line )[ \"tag\" ]","title":"get_tag_from_line()"},{"location":"reference/parsers/#parsers.entry.Line.get_tag_value_from_line","text":"Returns the value associated with a line in a gedcom file. If the line has no value, None is returned E.g. the line '1 NAME Dorothy Adela /Popp/ returns 'Dorothy Adela /Popp/ E.g. the line '1 BIRT' returns None Source code in parsers/entry.py @staticmethod def get_tag_value_from_line ( line : str ) -> str : \"\"\"Returns the value associated with a line in a gedcom file. If the line has no value, None is returned E.g. the line '1 NAME Dorothy Adela /Popp/` returns 'Dorothy Adela /Popp/` E.g. the line '1 BIRT' returns None \"\"\" return Line . get_parts_from_line ( line = line )[ \"tag_value\" ]","title":"get_tag_value_from_line()"},{"location":"reference/parsers/#parsers.entry.Line.to_str","text":"Converts a line object to a string Source code in parsers/entry.py def to_str ( self ) -> str : \"\"\"Converts a line object to a string\"\"\" ret = f \" { self . depth } { self . tag } \" if self . tag_value is not None : ret = f \" { ret } { self . tag_value } \" return ret","title":"to_str()"},{"location":"reference/parsers/#parsers.gedcom_file","text":"Contains the GedcomFile class which is the main entry point for parsing a .ged file","title":"gedcom_file"},{"location":"reference/parsers/#parsers.gedcom_file.GedcomFile","text":"Represents the contents of a Gedcom file. Takes the contents of a gedcom file and provides an interface for interpreting the contents and converting each section to CSV format.","title":"GedcomFile"},{"location":"reference/parsers/#parsers.gedcom_file.GedcomFile--parameters","text":"gedcom_str : str The contents of a GEDCOM file as a string no_cont_conc : bool Whether or not to preserve data from CONT (continue) and CONC (concatenate) tags in the gedcom file force_string_dates : bool Date values are prepended with a single quote mark (\"'\") if True. This helps render dates as strings in Microsoft Excel, e.g.","title":"Parameters"},{"location":"reference/parsers/#parsers.gedcom_file.GedcomFile--methods","text":"get_all_records_csv(encoding=\"utf-8\") Returns a dictionary of CSV format strings. Keys are \"INDI\", \"FAM\", and \"SOUR\". get_section_records_csv(section, encoding=\"utf-8\") Returns the individual records formatted as a CSV Source code in parsers/gedcom_file.py class GedcomFile : \"\"\"Represents the contents of a Gedcom file. Takes the contents of a gedcom file and provides an interface for interpreting the contents and converting each section to CSV format. Parameters ---------- gedcom_str : str The contents of a GEDCOM file as a string no_cont_conc : bool Whether or not to preserve data from CONT (continue) and CONC (concatenate) tags in the gedcom file force_string_dates : bool Date values are prepended with a single quote mark (\"'\") if True. This helps render dates as strings in Microsoft Excel, e.g. Methods ------- get_all_records_csv(encoding=\"utf-8\") Returns a dictionary of CSV format strings. Keys are \"INDI\", \"FAM\", and \"SOUR\". get_section_records_csv(section, encoding=\"utf-8\") Returns the individual records formatted as a CSV \"\"\" def __init__ ( self , gedcom_str : str , no_cont_conc : bool , force_string_dates : bool , ) -> None : self . gedcom_lines = gedcom_str . split ( \" \\n \" ) self . no_cont_conc = no_cont_conc self . force_string_dates = force_string_dates def get_all_records_csv ( self , encoding : str = \"utf-8\" ) -> Dict [ str , str ]: \"\"\"Converts gedcom_str into separate CSV strings for indi, fam, and sour records Parameters ---------- encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- Dict[str, str] A dictionary of entry type to csv strings with the following keys: - \"INDI\": individual entries csv string, - \"FAM\": family entries csv string, - \"SOUR\": source entries csv string, \"\"\" return { \"INDI\" : self . get_section_records_csv ( section = \"indi\" , encoding = encoding ), \"FAM\" : self . get_section_records_csv ( section = \"fam\" , encoding = encoding ), \"SOUR\" : self . get_section_records_csv ( section = \"sour\" , encoding = encoding ), } def get_section_records_csv ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ], encoding : str = \"utf-8\" ) -> str : \"\"\"Returns the records of a type as a CSV formatted string Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section-type to convert to CSV and return encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- str \"\"\" entries = self . _get_section_entries ( section = section ) df = self . _get_entries_df ( entries = entries ) return self . _convert_df_to_csv ( df = df , encoding = encoding ) def _get_entries_df ( self , entries : List [ Entry ]) -> pd . DataFrame : \"\"\"Converts a list of entries into a pandas DataFrame object Parameters ---------- entries : List[Entry] Returns ------- pd.DataFrame \"\"\" return pd . DataFrame ( x . to_col_name_dict () for x in entries ) def _convert_df_to_csv ( self , df : pd . DataFrame , encoding : str = \"utf-8\" ) -> str : \"\"\"Accepts a dataframe and returns it formatted as a CSV string Parameters ---------- df : pd.DataFrame encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- str A CSV-formatted string with the contents of df \"\"\" return df . to_csv ( header = True , index = False , encoding = encoding ) def _get_section_entries ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ]) -> List [ Entry ]: \"\"\"Parses a section of the gedcom string and instantiates Entry items for the section Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section of the gedcom string to process Returns ------- List[Entry] A list of Entry objects, one for each primary 0-level entry in the given section Raises ------ RuntimeError if the section boundaries cannot be determined from the gedcom file. This indicates a mal-formed gedcom file. \"\"\" ret = [] start_line_index = self . _get_section_start_index ( section = section ) end_line_index = self . _get_section_end_index ( section = section ) if ( start_line_index is None ) ^ ( end_line_index is None ): raise RuntimeError ( f \"Cannot determine boundaries of { section } in the provided gedcom string. \\n \" \" Ensure that the GEDCOM file is formatted correctly and try again.\" ) elif start_line_index : assert end_line_index is not None i = start_line_index while i <= end_line_index : j = i + 1 while j < len ( self . gedcom_lines ) and not self . gedcom_lines [ j ] . startswith ( \"0\" ): j += 1 assert j <= end_line_index + 1 assert self . gedcom_lines [ i ] . startswith ( \"0\" ) assert self . gedcom_lines [ j ] . startswith ( \"0\" ) LOG . debug ( f \"RECORD LINES { i } - { j } :\" ) for k in range ( i , j ): LOG . debug ( f \" \\t { self . gedcom_lines [ k ] } \" ) ret . append ( Entry ( lines = self . gedcom_lines [ i : j ], force_string_dates = self . force_string_dates , no_cont_conc = self . no_cont_conc , ) ) i = j return ret def _get_section_start_index ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ]) -> Union [ int , None ]: \"\"\"Returns the section start line index Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section to seek the beginning of Returns ------- Union[int, None] The line index (zero-indexed) of the gedcom string that marks the beginning of the requested section. If None is returned, this indicates the section is absent from the gedcom file \"\"\" pattern = self . _get_entry_regex_pattern ( section = section ) # find first instance of match ret = None for i , line in enumerate ( self . gedcom_lines ): if pattern . match ( line ): ret = i break LOG . debug ( f \"Start index of { section } determined: { ret } \" ) return ret def _get_section_end_index ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ]) -> int : \"\"\"Returns the section end line index Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section to seek the end of Returns ------- Union[int, None] The line index (zero-indexed) of the gedcom string that marks the end of the requested section. If None is returned, this indicates the section is absent from the gedcom file \"\"\" pattern = self . _get_entry_regex_pattern ( section = section ) ret = None i = len ( self . gedcom_lines ) - 1 # start from the end of the gedcom file and work backwards searching for the last line that # matches the provided entry pattern end_found = False while i > 0 and not end_found : if pattern . match ( self . gedcom_lines [ i ]): end_found = True i += 1 # Now start working back forwards to find the end of this indi entry while i < len ( self . gedcom_lines ) and not self . gedcom_lines [ i ] . startswith ( \"0\" ): i += 1 if self . gedcom_lines [ i ] . startswith ( \"0\" ): ret = i - 1 i -= 1 LOG . debug ( f \"End index of { section } determined: { ret } \" ) return ret def _get_entry_regex_pattern ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ]) -> Pattern : \"\"\"Returns a compiled regex pattern for matching 0-level entries for the given section type Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Returns ------- Pattern a compiled regex pattern that will match 0-level entries of the requested type Raises ------ ValueError if the provided section value does not match one of the available patterns \"\"\" if section == \"indi\" : ret = _INDI_REGEX elif section == \"fam\" : ret = _FAM_REGEX elif section == \"sour\" : ret = _SOUR_REGEX else : raise ValueError ( f \"invalid section type ' { section } ' provided\" ) return ret","title":"Methods"},{"location":"reference/parsers/#parsers.gedcom_file.GedcomFile.get_all_records_csv","text":"Converts gedcom_str into separate CSV strings for indi, fam, and sour records","title":"get_all_records_csv()"},{"location":"reference/parsers/#parsers.gedcom_file.GedcomFile.get_all_records_csv--parameters","text":"encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings.","title":"Parameters"},{"location":"reference/parsers/#parsers.gedcom_file.GedcomFile.get_all_records_csv--returns","text":"Dict[str, str] A dictionary of entry type to csv strings with the following keys: - \"INDI\": individual entries csv string, - \"FAM\": family entries csv string, - \"SOUR\": source entries csv string, Source code in parsers/gedcom_file.py def get_all_records_csv ( self , encoding : str = \"utf-8\" ) -> Dict [ str , str ]: \"\"\"Converts gedcom_str into separate CSV strings for indi, fam, and sour records Parameters ---------- encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- Dict[str, str] A dictionary of entry type to csv strings with the following keys: - \"INDI\": individual entries csv string, - \"FAM\": family entries csv string, - \"SOUR\": source entries csv string, \"\"\" return { \"INDI\" : self . get_section_records_csv ( section = \"indi\" , encoding = encoding ), \"FAM\" : self . get_section_records_csv ( section = \"fam\" , encoding = encoding ), \"SOUR\" : self . get_section_records_csv ( section = \"sour\" , encoding = encoding ), }","title":"Returns"},{"location":"reference/parsers/#parsers.gedcom_file.GedcomFile.get_section_records_csv","text":"Returns the records of a type as a CSV formatted string","title":"get_section_records_csv()"},{"location":"reference/parsers/#parsers.gedcom_file.GedcomFile.get_section_records_csv--parameters","text":"section : Literal[\"indi\", \"fam\", \"sour\"] Which section-type to convert to CSV and return encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings.","title":"Parameters"},{"location":"reference/parsers/#parsers.gedcom_file.GedcomFile.get_section_records_csv--returns","text":"str Source code in parsers/gedcom_file.py def get_section_records_csv ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ], encoding : str = \"utf-8\" ) -> str : \"\"\"Returns the records of a type as a CSV formatted string Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section-type to convert to CSV and return encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- str \"\"\" entries = self . _get_section_entries ( section = section ) df = self . _get_entries_df ( entries = entries ) return self . _convert_df_to_csv ( df = df , encoding = encoding )","title":"Returns"},{"location":"reference/parsers/entry/","text":"Entry!!! Entry Class to manage an entry. Where an entry is an entire INDI, FAM, or SOUR entry in a gedcom file Source code in parsers/entry.py class Entry : \"\"\"Class to manage an entry. Where an entry is an entire INDI, FAM, or SOUR entry in a gedcom file\"\"\" _EMPTY_LINE_PLACEHOLDER = \"<<NONE>>\" _CONT_PLACEHOLDER = \"<<CONT>>\" _MISSING_DATA_PLACEHOLDER = \"<<MISSING DATA>>\" _CONT_RE = re . compile ( \"^\\d+ CONT (?P<value>.*)\" ) _CONC_RE = re . compile ( \"^\\d+ CONC (?P<value>.*)\" ) _EMPTY_LINE_RE = re . compile ( r \"^\\d+ [A-Z_]{3,5}$\" ) _FIRST_LINE_RE = re . compile ( r \"^0 (?P<id>@[IFS]\\d+@) (?P<type>(?:INDI|FAM|SOUR))$\" ) _DATE_TAG = \"DATE\" _ACTIVE_TAG_SEPARATOR = \"+\" _SUFFIX_SEPARATOR = \"~\" def __init__ ( self , lines : List [ str ], force_string_dates : bool , no_cont_conc : bool ) -> None : f \"\"\" Parameters ---------- lines: List[str] A list of strings where each item in the list is a line of a gedcome file pertaining to the entry. The order is assumed to be top -> bottom as if reading the gedcom file force_string_dates: bool A flag that, when True, will add a single-quote (') in front of DATE values. This should force excel to render these values as strings rather than attempt to interpret them as dates. Which it isn't super good at. no_cont_conc: bool A flag that, when True, disables attempts to preserve all CONT and CONC data. Instead a missing data string is put in place of CONT and CONC continued/concatenated values. \"\"\" # the first line is not like the others. It contians the type of entry, and the id number self . ENTRY_DEBUG = env ( \"VERBOSE_OUTPUT\" , cast = bool , default = False ) # set self.id and self.type for k , v in self . get_first_line_dict ( lines [ 0 ]) . items (): setattr ( self , k , v ) self . force_string_dates = force_string_dates self . no_cont_conc = no_cont_conc self . lines = lines [ 1 :] @staticmethod def get_first_line_dict ( line ) -> dict : \"\"\"Parses the first line of an entry and returns a dict with the groups defined in _FIRST_LINE_RE\"\"\" match = Entry . _FIRST_LINE_RE . match ( line ) assert match return match . groupdict () @property def lines ( self ) -> List [ str ]: \"\"\"Returns self.lines as a list of strings\"\"\" return self . add_cont_conc ([ l . to_str () for l in self . _lines ]) @lines . setter def lines ( self , val ) -> None : \"\"\"Sets self.lines. Stores lines as line objects under the hood\"\"\" if not isinstance ( val , list ): raise ValueError ( f \"lines must be an instance of list, go { type ( val ) } \" ) elif not all ([ isinstance ( v , str ) for v in val ]): raise ValueError ( \"All lines must be string values\" ) else : if self . no_cont_conc : self . _lines = [ Line . from_str ( l ) for l in self . remove_cont_conc ( val )] else : self . _lines = [ Line . from_str ( l ) for l in self . collapse_cont_conc ( val )] def remove_cont_conc ( self , lines : List [ str ]) -> List [ str ]: r \"\"\"Removes CONT and CONC tags from a list of lines. Replaces them with a warning string Parameters ---------- lines: List[str] A list of gedcom file lines Returns ------- List[str] The processed gedcome file lines with CONT and CONC tags removed Example ------- Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long<<MISSING DATA>>\"] \"\"\" ret = [] skip = False for i , line in enumerate ( lines ): # eliminate trailing newline characters if line . endswith ( \" \\n \" ): line = line [: - 1 ] if self . _CONT_RE . match ( line ) or self . _CONC_RE . match ( line ): assert i > 0 # the logic in the below else statement should only be executed once per series of CONT/CONCs. So, # skip is set to True on the first CONT/CONC found and it is handled. Then it is re-set to False # upon detecting the next line that does not contain a CONT/CONC tag if skip : pass else : prev_line = ret [ - 1 ] skip = True if len ( prev_line ) > GEDCOM_MAX_LINE_LENGTH - len ( self . _MISSING_DATA_PLACEHOLDER ): # cut off the previous line so that the missing data placeholder can fit, then append the missing data placeholder ret [ - 1 ] = f \" { prev_line [: GEDCOM_MAX_LINE_LENGTH - len ( self . _MISSING_DATA_PLACEHOLDER )] }{ self . _MISSING_DATA_PLACEHOLDER } \" elif self . _EMPTY_LINE_RE . match ( prev_line ): # Add the missing data placeholder, but make sure there is a space between it and the tag prev_line = f \" { prev_line } { self . _MISSING_DATA_PLACEHOLDER } \" else : # Add the missing data placeholder prev_line = f \" { prev_line }{ self . _MISSING_DATA_PLACEHOLDER } \" else : skip = False ret . append ( line ) if self . ENTRY_DEBUG : print ( \"REMOVE_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret def collapse_cont_conc ( self , lines : List [ str ]) -> List [ str ]: r \"\"\"Accepts a list of strings, combines lines that are contineud via CONT/CONC. Returns the modified list Parameters ---------- lines: List[str] A list of gedcom file lines Returns ------- List[str] The processed gedcome file lines with CONT and CONC folded up into the lines that they continued/concatenated Example ------- Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long<<CONT>>long long long long long long note\"] \"\"\" \"\"\"Removes CONT and CONC tags in a list of lines by combining those lines into one line\"\"\" ret = [] for i , line in enumerate ( lines ): # remove errant trailing newline characters if line . endswith ( \" \\n \" ): line = line [: - 1 ] cont_match = self . _CONT_RE . match ( line ) conc_match = self . _CONC_RE . match ( line ) assert not ( cont_match and conc_match ) if cont_match : assert i != 0 if self . _EMPTY_LINE_RE . match ( ret [ - 1 ]): # if ret[-1] is nothing but a depth and tag, there needs to be a space before the CONT ret [ - 1 ] = f \" { ret [ - 1 ] } { self . _CONT_PLACEHOLDER }{ cont_match . groupdict ()[ 'value' ] } \" else : ret [ - 1 ] = f \" { ret [ - 1 ] }{ self . _CONT_PLACEHOLDER }{ cont_match . groupdict ()[ 'value' ] } \" elif conc_match : assert i != 0 assert not self . _EMPTY_LINE_RE . match ( ret [ - 1 ]) # simply append the concatenated value. No need to check for empty tags as by definition, conc # tags are not applied to empty lines ret [ - 1 ] = f \" { ret [ - 1 ] }{ conc_match . groupdict ()[ 'value' ] } \" else : # no processing necessary. Just append and move on ret . append ( line ) if self . ENTRY_DEBUG : print ( \"COLLAPSE_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret @staticmethod def add_cont_conc ( lines : List [ str ]) -> List [ str ]: def get_tag_value_chunk ( depth : Union [ int , str ], tag : str , tag_value : str ): \"\"\"Helper function to determine when and how to split a tag value Parameters ---------- depth: Union[int, str] the depth value for the line being examined tag: str the tag for the line being examined. E.g. DATE, PLAC or BURI tag_value: str the rest of the line being examined Returns ------- Tuple[bool, str, str, Union[str, None]] [0] - boolean: whether the tag_value needed to be split or not [1] - str: The tag for this line. Original tag, CONC, or CONT [2] - str: the value of the split-off section of tag_value [3] - str|None: the remainder of tag_value \"\"\" ret = ( False , tag , tag_value , None ) if tag_value is not None : len_depth = len ( str ( depth )) len_tag = len ( tag ) len_tag_value = len ( tag_value ) num_spaces = 2 if ( len_depth + len_tag + len_tag_value + num_spaces > GEDCOM_MAX_LINE_LENGTH or tag_value . find ( Entry . _CONT_PLACEHOLDER ) != - 1 ): newline_index = tag_value . find ( Entry . _CONT_PLACEHOLDER ) if newline_index != - 1 : if ( len_depth + len_tag + num_spaces + newline_index ) < GEDCOM_MAX_LINE_LENGTH : ret = ( True , \"CONT\" , tag_value . split ( Entry . _CONT_PLACEHOLDER )[ 0 ], Entry . _CONT_PLACEHOLDER . join ( tag_value . split ( Entry . _CONT_PLACEHOLDER )[ 1 :] ), ) else : ret = ( True , \"CONC\" , tag_value [ : GEDCOM_MAX_LINE_LENGTH - 1 - len_depth - len_tag - num_spaces ], tag_value [ GEDCOM_MAX_LINE_LENGTH - 1 - len_depth - len_tag - num_spaces : ], ) else : ret = ( True , \"CONC\" , tag_value [: GEDCOM_MAX_LINE_LENGTH - len_depth - len_tag - num_spaces ], tag_value [ GEDCOM_MAX_LINE_LENGTH - len_depth - len_tag - num_spaces :], ) else : pass else : pass return ret if env ( \"VERBOSE_OUTPUT\" , cast = bool , default = False ): print ( \"ADD_CONT_CONC input:\" ) for x in lines : print ( f \" \\t { x } \" ) ret = [] for i , line in enumerate ( lines ): depth = int ( Line . get_depth_from_line ( line )) tag = Line . get_tag_from_line ( line ) tag_value = Line . get_tag_value_from_line ( line ) need_split , new_tag , tag_value , next_tag_value = get_tag_value_chunk ( depth , tag , tag_value ) ret . append ( f \" { depth } { tag } { tag_value } \" ) while need_split : ( need_split , new_tag , prev_tag_value , next_tag_value ) = get_tag_value_chunk ( depth + 1 , new_tag , next_tag_value ) if prev_tag_value : ret . append ( f \" { depth + 1 } { new_tag } { prev_tag_value } \" ) else : ret . append ( f \" { depth + 1 } { new_tag } \" ) if env ( \"VERBOSE_OUTPUT\" , cast = bool , default = False ): print ( \"ADD_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret def to_col_name_dict ( self ): \"\"\"Transform lines into a CSV-file-friendly dictionary of col-title:value pairs Tags are folded into eachother so that one entry can occupy a single row of the CSV file. E.g. 0 @I42@ INDI 1 NAME Leonard Frank /Bartos/ 2 GIVN Leonard Frank 2 NSFX RPh 1 SEX M 1 _UID 4EF44217DF0F40419968D80B5CC5FE8491FB becomes { \"type\": \"INDI\", \"id:\" @I42@\", \"NAME\": \"Leonard Frand /Bartos/\", \"NAME+GIVN\": \"Leonard Frank\", \"NAME+NSFX\": \"RPh\", \"SEX\": \"M\", \"_UID\": \"4EF44217DF0F40419968D80B5CC5FE8491FB\", } \"\"\" # at minimum, id and type is needed ret = { \"id\" : self . id , \"tag_type\" : self . type } # a stack of active tags. The tags are concatenated together to form column headers active_tags = [] # iterate through the Line objects directly for i , line in enumerate ( self . _lines ): # Pop all no-longer-active tags off of the stack. The current line's depth - 1 # indicates how many of the active tags are still relevant. (The current line contributes # an active tag. Thus, the length of active tags should always equal the depth of the line if line . depth <= len ( active_tags ) + 1 : active_tags = active_tags [: ( line . depth - 1 )] active_tags . append ( line . tag ) # process tag_value. Tags with no value need a placeholder and date tags may need # adjusting depending on force_string_dates if line . tag_value is None : tag_value = self . _EMPTY_LINE_PLACEHOLDER elif ( line . tag == self . _DATE_TAG and self . force_string_dates and not line . tag . startswith ( \"'\" ) ): tag_value = f \"' { line . tag_value } \" else : tag_value = line . tag_value # Ensure unique column headers. E.g. if there are two NAME entries in a record and each # has a GIVN sub-property, the dictionary should look like: # { # \"NAME+GIVN\": \"value\", # \"NAME+GIVN_1\": \"other value\", # } suffix = 0 while self . _ACTIVE_TAG_SEPARATOR . join ( active_tags ) in ret : suffix += 1 active_tags [ - 1 ] = f \" { line . tag }{ self . _SUFFIX_SEPARATOR }{ suffix } \" ret [ \"+\" . join ( active_tags )] = tag_value if self . ENTRY_DEBUG : print ( \"--ENTRY AS DICT--\" ) for k , v in ret . items (): print ( f \" \\t { k } : { v } \" ) return ret lines : List [ str ] property writable Returns self.lines as a list of strings collapse_cont_conc ( self , lines ) Accepts a list of strings, combines lines that are contineud via CONT/CONC. Returns the modified list Parameters !!! lines \"List[str]\" A list of gedcom file lines Returns List[str] The processed gedcome file lines with CONT and CONC folded up into the lines that they continued/concatenated Example Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long< >long long long long long long note\"] Source code in parsers/entry.py def collapse_cont_conc ( self , lines : List [ str ]) -> List [ str ]: r \"\"\"Accepts a list of strings, combines lines that are contineud via CONT/CONC. Returns the modified list Parameters ---------- lines: List[str] A list of gedcom file lines Returns ------- List[str] The processed gedcome file lines with CONT and CONC folded up into the lines that they continued/concatenated Example ------- Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long<<CONT>>long long long long long long note\"] \"\"\" \"\"\"Removes CONT and CONC tags in a list of lines by combining those lines into one line\"\"\" ret = [] for i , line in enumerate ( lines ): # remove errant trailing newline characters if line . endswith ( \" \\n \" ): line = line [: - 1 ] cont_match = self . _CONT_RE . match ( line ) conc_match = self . _CONC_RE . match ( line ) assert not ( cont_match and conc_match ) if cont_match : assert i != 0 if self . _EMPTY_LINE_RE . match ( ret [ - 1 ]): # if ret[-1] is nothing but a depth and tag, there needs to be a space before the CONT ret [ - 1 ] = f \" { ret [ - 1 ] } { self . _CONT_PLACEHOLDER }{ cont_match . groupdict ()[ 'value' ] } \" else : ret [ - 1 ] = f \" { ret [ - 1 ] }{ self . _CONT_PLACEHOLDER }{ cont_match . groupdict ()[ 'value' ] } \" elif conc_match : assert i != 0 assert not self . _EMPTY_LINE_RE . match ( ret [ - 1 ]) # simply append the concatenated value. No need to check for empty tags as by definition, conc # tags are not applied to empty lines ret [ - 1 ] = f \" { ret [ - 1 ] }{ conc_match . groupdict ()[ 'value' ] } \" else : # no processing necessary. Just append and move on ret . append ( line ) if self . ENTRY_DEBUG : print ( \"COLLAPSE_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret get_first_line_dict ( line ) staticmethod Parses the first line of an entry and returns a dict with the groups defined in _FIRST_LINE_RE Source code in parsers/entry.py @staticmethod def get_first_line_dict ( line ) -> dict : \"\"\"Parses the first line of an entry and returns a dict with the groups defined in _FIRST_LINE_RE\"\"\" match = Entry . _FIRST_LINE_RE . match ( line ) assert match return match . groupdict () remove_cont_conc ( self , lines ) Removes CONT and CONC tags from a list of lines. Replaces them with a warning string Parameters !!! lines \"List[str]\" A list of gedcom file lines Returns List[str] The processed gedcome file lines with CONT and CONC tags removed Example Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long< >\"] Source code in parsers/entry.py def remove_cont_conc ( self , lines : List [ str ]) -> List [ str ]: r \"\"\"Removes CONT and CONC tags from a list of lines. Replaces them with a warning string Parameters ---------- lines: List[str] A list of gedcom file lines Returns ------- List[str] The processed gedcome file lines with CONT and CONC tags removed Example ------- Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long<<MISSING DATA>>\"] \"\"\" ret = [] skip = False for i , line in enumerate ( lines ): # eliminate trailing newline characters if line . endswith ( \" \\n \" ): line = line [: - 1 ] if self . _CONT_RE . match ( line ) or self . _CONC_RE . match ( line ): assert i > 0 # the logic in the below else statement should only be executed once per series of CONT/CONCs. So, # skip is set to True on the first CONT/CONC found and it is handled. Then it is re-set to False # upon detecting the next line that does not contain a CONT/CONC tag if skip : pass else : prev_line = ret [ - 1 ] skip = True if len ( prev_line ) > GEDCOM_MAX_LINE_LENGTH - len ( self . _MISSING_DATA_PLACEHOLDER ): # cut off the previous line so that the missing data placeholder can fit, then append the missing data placeholder ret [ - 1 ] = f \" { prev_line [: GEDCOM_MAX_LINE_LENGTH - len ( self . _MISSING_DATA_PLACEHOLDER )] }{ self . _MISSING_DATA_PLACEHOLDER } \" elif self . _EMPTY_LINE_RE . match ( prev_line ): # Add the missing data placeholder, but make sure there is a space between it and the tag prev_line = f \" { prev_line } { self . _MISSING_DATA_PLACEHOLDER } \" else : # Add the missing data placeholder prev_line = f \" { prev_line }{ self . _MISSING_DATA_PLACEHOLDER } \" else : skip = False ret . append ( line ) if self . ENTRY_DEBUG : print ( \"REMOVE_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret to_col_name_dict ( self ) Transform lines into a CSV-file-friendly dictionary of col-title:value pairs Tags are folded into eachother so that one entry can occupy a single row of the CSV file. E.g. 0 @I42@ INDI 1 NAME Leonard Frank /Bartos/ 2 GIVN Leonard Frank 2 NSFX RPh 1 SEX M 1 _UID 4EF44217DF0F40419968D80B5CC5FE8491FB becomes { \"type\": \"INDI\", \"id:\" @I42@\", \"NAME\": \"Leonard Frand /Bartos/\", \"NAME+GIVN\": \"Leonard Frank\", \"NAME+NSFX\": \"RPh\", \"SEX\": \"M\", \"_UID\": \"4EF44217DF0F40419968D80B5CC5FE8491FB\", } Source code in parsers/entry.py def to_col_name_dict ( self ): \"\"\"Transform lines into a CSV-file-friendly dictionary of col-title:value pairs Tags are folded into eachother so that one entry can occupy a single row of the CSV file. E.g. 0 @I42@ INDI 1 NAME Leonard Frank /Bartos/ 2 GIVN Leonard Frank 2 NSFX RPh 1 SEX M 1 _UID 4EF44217DF0F40419968D80B5CC5FE8491FB becomes { \"type\": \"INDI\", \"id:\" @I42@\", \"NAME\": \"Leonard Frand /Bartos/\", \"NAME+GIVN\": \"Leonard Frank\", \"NAME+NSFX\": \"RPh\", \"SEX\": \"M\", \"_UID\": \"4EF44217DF0F40419968D80B5CC5FE8491FB\", } \"\"\" # at minimum, id and type is needed ret = { \"id\" : self . id , \"tag_type\" : self . type } # a stack of active tags. The tags are concatenated together to form column headers active_tags = [] # iterate through the Line objects directly for i , line in enumerate ( self . _lines ): # Pop all no-longer-active tags off of the stack. The current line's depth - 1 # indicates how many of the active tags are still relevant. (The current line contributes # an active tag. Thus, the length of active tags should always equal the depth of the line if line . depth <= len ( active_tags ) + 1 : active_tags = active_tags [: ( line . depth - 1 )] active_tags . append ( line . tag ) # process tag_value. Tags with no value need a placeholder and date tags may need # adjusting depending on force_string_dates if line . tag_value is None : tag_value = self . _EMPTY_LINE_PLACEHOLDER elif ( line . tag == self . _DATE_TAG and self . force_string_dates and not line . tag . startswith ( \"'\" ) ): tag_value = f \"' { line . tag_value } \" else : tag_value = line . tag_value # Ensure unique column headers. E.g. if there are two NAME entries in a record and each # has a GIVN sub-property, the dictionary should look like: # { # \"NAME+GIVN\": \"value\", # \"NAME+GIVN_1\": \"other value\", # } suffix = 0 while self . _ACTIVE_TAG_SEPARATOR . join ( active_tags ) in ret : suffix += 1 active_tags [ - 1 ] = f \" { line . tag }{ self . _SUFFIX_SEPARATOR }{ suffix } \" ret [ \"+\" . join ( active_tags )] = tag_value if self . ENTRY_DEBUG : print ( \"--ENTRY AS DICT--\" ) for k , v in ret . items (): print ( f \" \\t { k } : { v } \" ) return ret Line Source code in parsers/entry.py class Line : _LINE_RE = re . compile ( r \"^(?P<depth>[0-9]+) (?P<tag>[0-9A-Z_]+)(?: (?P<tag_value>.*))?$\" ) \"\"\"Represents a single line of a gedcom file A line has three parts: depth, tag, and tag_value. The third, tag_value, is optional. The format of a line is: {depth} {tag}[ {tag_value}] Seome examples are: 0 INDI @Ixxx@ 1 DEAT 2 DATE 1876 \"\"\" def __init__ ( self , depth : Union [ str , int ], tag : str , tag_value : Optional [ str ] = None ): r \"\"\" Parameters ---------- depth: Union[str, int] The depth of the gedcom file line. Depth is the first part of a line entry. Typically a single digit 0-3 tag: str The tag of the gedcome file line. E.g. \"NAME\", \"BIRT\", or \"_PLAC\" tag_value: Optional[str], default: None The value corresponding to the tag. E.g. \"John \\Cleese\\\" \"\"\" self . depth = depth self . tag = tag self . tag_value = tag_value @staticmethod def get_parts_from_line ( line : str ) -> dict : r \"\"\"Accepts a gedcome line, parses its constituent parts and returns them as a dictionary Parameters ---------- line: str Returns ------- dict with keys \"depth\", \"tag\", and \"tag_value\". All values in the dict are strings, though \"tag_value\" may have a value of None. \"\"\" m = Line . _LINE_RE . match ( line ) if not m : raise ValueError ( f \"Invalid gedcom line recieved: { line } \" ) return m . groupdict () @classmethod def from_str ( cls , line : str ): \"\"\"Accepts a string and returns a Line object\"\"\" return cls ( ** cls . get_parts_from_line ( line )) def to_str ( self ) -> str : \"\"\"Converts a line object to a string\"\"\" ret = f \" { self . depth } { self . tag } \" if self . tag_value is not None : ret = f \" { ret } { self . tag_value } \" return ret @staticmethod def get_depth_from_line ( line : str ) -> str : \"\"\"Returns the depth value from a gedcom file line. E.g. A NAME line may look like '1 NAME Leonard Frank /Bartos/'. Here the depth is 1, meaning this is a first-order property of a base entry. E.g. A SURN line may look like '2 GIVN Leonard Frank'. Here the depth is 2, meaning this is a second-order property of a base entry (a first-order property of a NAME line, probably). \"\"\" return Line . get_parts_from_line ( line = line )[ \"depth\" ] @staticmethod def get_tag_from_line ( line : str ) -> str : \"\"\"Returns the tag name from a gedcom file line. E.g. 'NAME', 'BIRT', 'FAMS'\"\"\" return Line . get_parts_from_line ( line = line )[ \"tag\" ] @staticmethod def get_tag_value_from_line ( line : str ) -> str : \"\"\"Returns the value associated with a line in a gedcom file. If the line has no value, None is returned E.g. the line '1 NAME Dorothy Adela /Popp/` returns 'Dorothy Adela /Popp/` E.g. the line '1 BIRT' returns None \"\"\" return Line . get_parts_from_line ( line = line )[ \"tag_value\" ] @property def line ( self ): return self . _line @line . setter def line ( self , val ): if not isinstance ( val , str ): raise ValueError ( f \"invalid line type of { type ( val ) } \" ) else : self . _line = val @property def depth ( self ): return self . _depth @depth . setter def depth ( self , val ): if not isinstance ( val , ( str , int )): raise ValueError ( f \"invalid depth type of { type ( val ) } \" ) else : self . _depth = int ( val ) @property def tag ( self ): return self . _tag @tag . setter def tag ( self , val ): if not isinstance ( val , str ): raise ValueError ( f \"invalid tag type of { type ( val ) } \" ) else : self . _tag = val @property def tag_value ( self ): return self . _tag_value @tag_value . setter def tag_value ( self , val ): if val is not None and not isinstance ( val , str ): raise ValueError ( f \"invalid tag_value type of { type ( val ) } \" ) else : self . _tag_value = val __init__ ( self , depth , tag , tag_value = None ) special Parameters !!! depth \"Union[str, int]\" The depth of the gedcom file line. Depth is the first part of a line entry. Typically a single digit 0-3 !!! tag \"str\" The tag of the gedcome file line. E.g. \"NAME\", \"BIRT\", or \"_PLAC\" !!! tag_value \"Optional[str], default: None\" The value corresponding to the tag. E.g. \"John \\Cleese\\\" Source code in parsers/entry.py def __init__ ( self , depth : Union [ str , int ], tag : str , tag_value : Optional [ str ] = None ): r \"\"\" Parameters ---------- depth: Union[str, int] The depth of the gedcom file line. Depth is the first part of a line entry. Typically a single digit 0-3 tag: str The tag of the gedcome file line. E.g. \"NAME\", \"BIRT\", or \"_PLAC\" tag_value: Optional[str], default: None The value corresponding to the tag. E.g. \"John \\Cleese\\\" \"\"\" self . depth = depth self . tag = tag self . tag_value = tag_value from_str ( line ) classmethod Accepts a string and returns a Line object Source code in parsers/entry.py @classmethod def from_str ( cls , line : str ): \"\"\"Accepts a string and returns a Line object\"\"\" return cls ( ** cls . get_parts_from_line ( line )) get_depth_from_line ( line ) staticmethod Returns the depth value from a gedcom file line. E.g. A NAME line may look like '1 NAME Leonard Frank /Bartos/'. Here the depth is 1, meaning this is a first-order property of a base entry. E.g. A SURN line may look like '2 GIVN Leonard Frank'. Here the depth is 2, meaning this is a second-order property of a base entry (a first-order property of a NAME line, probably). Source code in parsers/entry.py @staticmethod def get_depth_from_line ( line : str ) -> str : \"\"\"Returns the depth value from a gedcom file line. E.g. A NAME line may look like '1 NAME Leonard Frank /Bartos/'. Here the depth is 1, meaning this is a first-order property of a base entry. E.g. A SURN line may look like '2 GIVN Leonard Frank'. Here the depth is 2, meaning this is a second-order property of a base entry (a first-order property of a NAME line, probably). \"\"\" return Line . get_parts_from_line ( line = line )[ \"depth\" ] get_parts_from_line ( line ) staticmethod Accepts a gedcome line, parses its constituent parts and returns them as a dictionary Parameters line: str Returns dict with keys \"depth\", \"tag\", and \"tag_value\". All values in the dict are strings, though \"tag_value\" may have a value of None. Source code in parsers/entry.py @staticmethod def get_parts_from_line ( line : str ) -> dict : r \"\"\"Accepts a gedcome line, parses its constituent parts and returns them as a dictionary Parameters ---------- line: str Returns ------- dict with keys \"depth\", \"tag\", and \"tag_value\". All values in the dict are strings, though \"tag_value\" may have a value of None. \"\"\" m = Line . _LINE_RE . match ( line ) if not m : raise ValueError ( f \"Invalid gedcom line recieved: { line } \" ) return m . groupdict () get_tag_from_line ( line ) staticmethod Returns the tag name from a gedcom file line. E.g. 'NAME', 'BIRT', 'FAMS' Source code in parsers/entry.py @staticmethod def get_tag_from_line ( line : str ) -> str : \"\"\"Returns the tag name from a gedcom file line. E.g. 'NAME', 'BIRT', 'FAMS'\"\"\" return Line . get_parts_from_line ( line = line )[ \"tag\" ] get_tag_value_from_line ( line ) staticmethod Returns the value associated with a line in a gedcom file. If the line has no value, None is returned E.g. the line '1 NAME Dorothy Adela /Popp/ returns 'Dorothy Adela /Popp/ E.g. the line '1 BIRT' returns None Source code in parsers/entry.py @staticmethod def get_tag_value_from_line ( line : str ) -> str : \"\"\"Returns the value associated with a line in a gedcom file. If the line has no value, None is returned E.g. the line '1 NAME Dorothy Adela /Popp/` returns 'Dorothy Adela /Popp/` E.g. the line '1 BIRT' returns None \"\"\" return Line . get_parts_from_line ( line = line )[ \"tag_value\" ] to_str ( self ) Converts a line object to a string Source code in parsers/entry.py def to_str ( self ) -> str : \"\"\"Converts a line object to a string\"\"\" ret = f \" { self . depth } { self . tag } \" if self . tag_value is not None : ret = f \" { ret } { self . tag_value } \" return ret","title":"entry"},{"location":"reference/parsers/entry/#parsers.entry.Entry","text":"Class to manage an entry. Where an entry is an entire INDI, FAM, or SOUR entry in a gedcom file Source code in parsers/entry.py class Entry : \"\"\"Class to manage an entry. Where an entry is an entire INDI, FAM, or SOUR entry in a gedcom file\"\"\" _EMPTY_LINE_PLACEHOLDER = \"<<NONE>>\" _CONT_PLACEHOLDER = \"<<CONT>>\" _MISSING_DATA_PLACEHOLDER = \"<<MISSING DATA>>\" _CONT_RE = re . compile ( \"^\\d+ CONT (?P<value>.*)\" ) _CONC_RE = re . compile ( \"^\\d+ CONC (?P<value>.*)\" ) _EMPTY_LINE_RE = re . compile ( r \"^\\d+ [A-Z_]{3,5}$\" ) _FIRST_LINE_RE = re . compile ( r \"^0 (?P<id>@[IFS]\\d+@) (?P<type>(?:INDI|FAM|SOUR))$\" ) _DATE_TAG = \"DATE\" _ACTIVE_TAG_SEPARATOR = \"+\" _SUFFIX_SEPARATOR = \"~\" def __init__ ( self , lines : List [ str ], force_string_dates : bool , no_cont_conc : bool ) -> None : f \"\"\" Parameters ---------- lines: List[str] A list of strings where each item in the list is a line of a gedcome file pertaining to the entry. The order is assumed to be top -> bottom as if reading the gedcom file force_string_dates: bool A flag that, when True, will add a single-quote (') in front of DATE values. This should force excel to render these values as strings rather than attempt to interpret them as dates. Which it isn't super good at. no_cont_conc: bool A flag that, when True, disables attempts to preserve all CONT and CONC data. Instead a missing data string is put in place of CONT and CONC continued/concatenated values. \"\"\" # the first line is not like the others. It contians the type of entry, and the id number self . ENTRY_DEBUG = env ( \"VERBOSE_OUTPUT\" , cast = bool , default = False ) # set self.id and self.type for k , v in self . get_first_line_dict ( lines [ 0 ]) . items (): setattr ( self , k , v ) self . force_string_dates = force_string_dates self . no_cont_conc = no_cont_conc self . lines = lines [ 1 :] @staticmethod def get_first_line_dict ( line ) -> dict : \"\"\"Parses the first line of an entry and returns a dict with the groups defined in _FIRST_LINE_RE\"\"\" match = Entry . _FIRST_LINE_RE . match ( line ) assert match return match . groupdict () @property def lines ( self ) -> List [ str ]: \"\"\"Returns self.lines as a list of strings\"\"\" return self . add_cont_conc ([ l . to_str () for l in self . _lines ]) @lines . setter def lines ( self , val ) -> None : \"\"\"Sets self.lines. Stores lines as line objects under the hood\"\"\" if not isinstance ( val , list ): raise ValueError ( f \"lines must be an instance of list, go { type ( val ) } \" ) elif not all ([ isinstance ( v , str ) for v in val ]): raise ValueError ( \"All lines must be string values\" ) else : if self . no_cont_conc : self . _lines = [ Line . from_str ( l ) for l in self . remove_cont_conc ( val )] else : self . _lines = [ Line . from_str ( l ) for l in self . collapse_cont_conc ( val )] def remove_cont_conc ( self , lines : List [ str ]) -> List [ str ]: r \"\"\"Removes CONT and CONC tags from a list of lines. Replaces them with a warning string Parameters ---------- lines: List[str] A list of gedcom file lines Returns ------- List[str] The processed gedcome file lines with CONT and CONC tags removed Example ------- Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long<<MISSING DATA>>\"] \"\"\" ret = [] skip = False for i , line in enumerate ( lines ): # eliminate trailing newline characters if line . endswith ( \" \\n \" ): line = line [: - 1 ] if self . _CONT_RE . match ( line ) or self . _CONC_RE . match ( line ): assert i > 0 # the logic in the below else statement should only be executed once per series of CONT/CONCs. So, # skip is set to True on the first CONT/CONC found and it is handled. Then it is re-set to False # upon detecting the next line that does not contain a CONT/CONC tag if skip : pass else : prev_line = ret [ - 1 ] skip = True if len ( prev_line ) > GEDCOM_MAX_LINE_LENGTH - len ( self . _MISSING_DATA_PLACEHOLDER ): # cut off the previous line so that the missing data placeholder can fit, then append the missing data placeholder ret [ - 1 ] = f \" { prev_line [: GEDCOM_MAX_LINE_LENGTH - len ( self . _MISSING_DATA_PLACEHOLDER )] }{ self . _MISSING_DATA_PLACEHOLDER } \" elif self . _EMPTY_LINE_RE . match ( prev_line ): # Add the missing data placeholder, but make sure there is a space between it and the tag prev_line = f \" { prev_line } { self . _MISSING_DATA_PLACEHOLDER } \" else : # Add the missing data placeholder prev_line = f \" { prev_line }{ self . _MISSING_DATA_PLACEHOLDER } \" else : skip = False ret . append ( line ) if self . ENTRY_DEBUG : print ( \"REMOVE_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret def collapse_cont_conc ( self , lines : List [ str ]) -> List [ str ]: r \"\"\"Accepts a list of strings, combines lines that are contineud via CONT/CONC. Returns the modified list Parameters ---------- lines: List[str] A list of gedcom file lines Returns ------- List[str] The processed gedcome file lines with CONT and CONC folded up into the lines that they continued/concatenated Example ------- Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long<<CONT>>long long long long long long note\"] \"\"\" \"\"\"Removes CONT and CONC tags in a list of lines by combining those lines into one line\"\"\" ret = [] for i , line in enumerate ( lines ): # remove errant trailing newline characters if line . endswith ( \" \\n \" ): line = line [: - 1 ] cont_match = self . _CONT_RE . match ( line ) conc_match = self . _CONC_RE . match ( line ) assert not ( cont_match and conc_match ) if cont_match : assert i != 0 if self . _EMPTY_LINE_RE . match ( ret [ - 1 ]): # if ret[-1] is nothing but a depth and tag, there needs to be a space before the CONT ret [ - 1 ] = f \" { ret [ - 1 ] } { self . _CONT_PLACEHOLDER }{ cont_match . groupdict ()[ 'value' ] } \" else : ret [ - 1 ] = f \" { ret [ - 1 ] }{ self . _CONT_PLACEHOLDER }{ cont_match . groupdict ()[ 'value' ] } \" elif conc_match : assert i != 0 assert not self . _EMPTY_LINE_RE . match ( ret [ - 1 ]) # simply append the concatenated value. No need to check for empty tags as by definition, conc # tags are not applied to empty lines ret [ - 1 ] = f \" { ret [ - 1 ] }{ conc_match . groupdict ()[ 'value' ] } \" else : # no processing necessary. Just append and move on ret . append ( line ) if self . ENTRY_DEBUG : print ( \"COLLAPSE_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret @staticmethod def add_cont_conc ( lines : List [ str ]) -> List [ str ]: def get_tag_value_chunk ( depth : Union [ int , str ], tag : str , tag_value : str ): \"\"\"Helper function to determine when and how to split a tag value Parameters ---------- depth: Union[int, str] the depth value for the line being examined tag: str the tag for the line being examined. E.g. DATE, PLAC or BURI tag_value: str the rest of the line being examined Returns ------- Tuple[bool, str, str, Union[str, None]] [0] - boolean: whether the tag_value needed to be split or not [1] - str: The tag for this line. Original tag, CONC, or CONT [2] - str: the value of the split-off section of tag_value [3] - str|None: the remainder of tag_value \"\"\" ret = ( False , tag , tag_value , None ) if tag_value is not None : len_depth = len ( str ( depth )) len_tag = len ( tag ) len_tag_value = len ( tag_value ) num_spaces = 2 if ( len_depth + len_tag + len_tag_value + num_spaces > GEDCOM_MAX_LINE_LENGTH or tag_value . find ( Entry . _CONT_PLACEHOLDER ) != - 1 ): newline_index = tag_value . find ( Entry . _CONT_PLACEHOLDER ) if newline_index != - 1 : if ( len_depth + len_tag + num_spaces + newline_index ) < GEDCOM_MAX_LINE_LENGTH : ret = ( True , \"CONT\" , tag_value . split ( Entry . _CONT_PLACEHOLDER )[ 0 ], Entry . _CONT_PLACEHOLDER . join ( tag_value . split ( Entry . _CONT_PLACEHOLDER )[ 1 :] ), ) else : ret = ( True , \"CONC\" , tag_value [ : GEDCOM_MAX_LINE_LENGTH - 1 - len_depth - len_tag - num_spaces ], tag_value [ GEDCOM_MAX_LINE_LENGTH - 1 - len_depth - len_tag - num_spaces : ], ) else : ret = ( True , \"CONC\" , tag_value [: GEDCOM_MAX_LINE_LENGTH - len_depth - len_tag - num_spaces ], tag_value [ GEDCOM_MAX_LINE_LENGTH - len_depth - len_tag - num_spaces :], ) else : pass else : pass return ret if env ( \"VERBOSE_OUTPUT\" , cast = bool , default = False ): print ( \"ADD_CONT_CONC input:\" ) for x in lines : print ( f \" \\t { x } \" ) ret = [] for i , line in enumerate ( lines ): depth = int ( Line . get_depth_from_line ( line )) tag = Line . get_tag_from_line ( line ) tag_value = Line . get_tag_value_from_line ( line ) need_split , new_tag , tag_value , next_tag_value = get_tag_value_chunk ( depth , tag , tag_value ) ret . append ( f \" { depth } { tag } { tag_value } \" ) while need_split : ( need_split , new_tag , prev_tag_value , next_tag_value ) = get_tag_value_chunk ( depth + 1 , new_tag , next_tag_value ) if prev_tag_value : ret . append ( f \" { depth + 1 } { new_tag } { prev_tag_value } \" ) else : ret . append ( f \" { depth + 1 } { new_tag } \" ) if env ( \"VERBOSE_OUTPUT\" , cast = bool , default = False ): print ( \"ADD_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret def to_col_name_dict ( self ): \"\"\"Transform lines into a CSV-file-friendly dictionary of col-title:value pairs Tags are folded into eachother so that one entry can occupy a single row of the CSV file. E.g. 0 @I42@ INDI 1 NAME Leonard Frank /Bartos/ 2 GIVN Leonard Frank 2 NSFX RPh 1 SEX M 1 _UID 4EF44217DF0F40419968D80B5CC5FE8491FB becomes { \"type\": \"INDI\", \"id:\" @I42@\", \"NAME\": \"Leonard Frand /Bartos/\", \"NAME+GIVN\": \"Leonard Frank\", \"NAME+NSFX\": \"RPh\", \"SEX\": \"M\", \"_UID\": \"4EF44217DF0F40419968D80B5CC5FE8491FB\", } \"\"\" # at minimum, id and type is needed ret = { \"id\" : self . id , \"tag_type\" : self . type } # a stack of active tags. The tags are concatenated together to form column headers active_tags = [] # iterate through the Line objects directly for i , line in enumerate ( self . _lines ): # Pop all no-longer-active tags off of the stack. The current line's depth - 1 # indicates how many of the active tags are still relevant. (The current line contributes # an active tag. Thus, the length of active tags should always equal the depth of the line if line . depth <= len ( active_tags ) + 1 : active_tags = active_tags [: ( line . depth - 1 )] active_tags . append ( line . tag ) # process tag_value. Tags with no value need a placeholder and date tags may need # adjusting depending on force_string_dates if line . tag_value is None : tag_value = self . _EMPTY_LINE_PLACEHOLDER elif ( line . tag == self . _DATE_TAG and self . force_string_dates and not line . tag . startswith ( \"'\" ) ): tag_value = f \"' { line . tag_value } \" else : tag_value = line . tag_value # Ensure unique column headers. E.g. if there are two NAME entries in a record and each # has a GIVN sub-property, the dictionary should look like: # { # \"NAME+GIVN\": \"value\", # \"NAME+GIVN_1\": \"other value\", # } suffix = 0 while self . _ACTIVE_TAG_SEPARATOR . join ( active_tags ) in ret : suffix += 1 active_tags [ - 1 ] = f \" { line . tag }{ self . _SUFFIX_SEPARATOR }{ suffix } \" ret [ \"+\" . join ( active_tags )] = tag_value if self . ENTRY_DEBUG : print ( \"--ENTRY AS DICT--\" ) for k , v in ret . items (): print ( f \" \\t { k } : { v } \" ) return ret","title":"Entry"},{"location":"reference/parsers/entry/#parsers.entry.Entry.lines","text":"Returns self.lines as a list of strings","title":"lines"},{"location":"reference/parsers/entry/#parsers.entry.Entry.collapse_cont_conc","text":"Accepts a list of strings, combines lines that are contineud via CONT/CONC. Returns the modified list","title":"collapse_cont_conc()"},{"location":"reference/parsers/entry/#parsers.entry.Entry.collapse_cont_conc--parameters","text":"!!! lines \"List[str]\" A list of gedcom file lines","title":"Parameters"},{"location":"reference/parsers/entry/#parsers.entry.Entry.collapse_cont_conc--returns","text":"List[str] The processed gedcome file lines with CONT and CONC folded up into the lines that they continued/concatenated","title":"Returns"},{"location":"reference/parsers/entry/#parsers.entry.Entry.collapse_cont_conc--example","text":"Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long< >long long long long long long note\"] Source code in parsers/entry.py def collapse_cont_conc ( self , lines : List [ str ]) -> List [ str ]: r \"\"\"Accepts a list of strings, combines lines that are contineud via CONT/CONC. Returns the modified list Parameters ---------- lines: List[str] A list of gedcom file lines Returns ------- List[str] The processed gedcome file lines with CONT and CONC folded up into the lines that they continued/concatenated Example ------- Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long<<CONT>>long long long long long long note\"] \"\"\" \"\"\"Removes CONT and CONC tags in a list of lines by combining those lines into one line\"\"\" ret = [] for i , line in enumerate ( lines ): # remove errant trailing newline characters if line . endswith ( \" \\n \" ): line = line [: - 1 ] cont_match = self . _CONT_RE . match ( line ) conc_match = self . _CONC_RE . match ( line ) assert not ( cont_match and conc_match ) if cont_match : assert i != 0 if self . _EMPTY_LINE_RE . match ( ret [ - 1 ]): # if ret[-1] is nothing but a depth and tag, there needs to be a space before the CONT ret [ - 1 ] = f \" { ret [ - 1 ] } { self . _CONT_PLACEHOLDER }{ cont_match . groupdict ()[ 'value' ] } \" else : ret [ - 1 ] = f \" { ret [ - 1 ] }{ self . _CONT_PLACEHOLDER }{ cont_match . groupdict ()[ 'value' ] } \" elif conc_match : assert i != 0 assert not self . _EMPTY_LINE_RE . match ( ret [ - 1 ]) # simply append the concatenated value. No need to check for empty tags as by definition, conc # tags are not applied to empty lines ret [ - 1 ] = f \" { ret [ - 1 ] }{ conc_match . groupdict ()[ 'value' ] } \" else : # no processing necessary. Just append and move on ret . append ( line ) if self . ENTRY_DEBUG : print ( \"COLLAPSE_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret","title":"Example"},{"location":"reference/parsers/entry/#parsers.entry.Entry.get_first_line_dict","text":"Parses the first line of an entry and returns a dict with the groups defined in _FIRST_LINE_RE Source code in parsers/entry.py @staticmethod def get_first_line_dict ( line ) -> dict : \"\"\"Parses the first line of an entry and returns a dict with the groups defined in _FIRST_LINE_RE\"\"\" match = Entry . _FIRST_LINE_RE . match ( line ) assert match return match . groupdict ()","title":"get_first_line_dict()"},{"location":"reference/parsers/entry/#parsers.entry.Entry.remove_cont_conc","text":"Removes CONT and CONC tags from a list of lines. Replaces them with a warning string","title":"remove_cont_conc()"},{"location":"reference/parsers/entry/#parsers.entry.Entry.remove_cont_conc--parameters","text":"!!! lines \"List[str]\" A list of gedcom file lines","title":"Parameters"},{"location":"reference/parsers/entry/#parsers.entry.Entry.remove_cont_conc--returns","text":"List[str] The processed gedcome file lines with CONT and CONC tags removed","title":"Returns"},{"location":"reference/parsers/entry/#parsers.entry.Entry.remove_cont_conc--example","text":"Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long< >\"] Source code in parsers/entry.py def remove_cont_conc ( self , lines : List [ str ]) -> List [ str ]: r \"\"\"Removes CONT and CONC tags from a list of lines. Replaces them with a warning string Parameters ---------- lines: List[str] A list of gedcom file lines Returns ------- List[str] The processed gedcome file lines with CONT and CONC tags removed Example ------- Input: [\"0 NOTE This is a long\", \"1 CONT long long long \", \"1 CONC long long long note\"] Output: [\"0 NOTE This is a long<<MISSING DATA>>\"] \"\"\" ret = [] skip = False for i , line in enumerate ( lines ): # eliminate trailing newline characters if line . endswith ( \" \\n \" ): line = line [: - 1 ] if self . _CONT_RE . match ( line ) or self . _CONC_RE . match ( line ): assert i > 0 # the logic in the below else statement should only be executed once per series of CONT/CONCs. So, # skip is set to True on the first CONT/CONC found and it is handled. Then it is re-set to False # upon detecting the next line that does not contain a CONT/CONC tag if skip : pass else : prev_line = ret [ - 1 ] skip = True if len ( prev_line ) > GEDCOM_MAX_LINE_LENGTH - len ( self . _MISSING_DATA_PLACEHOLDER ): # cut off the previous line so that the missing data placeholder can fit, then append the missing data placeholder ret [ - 1 ] = f \" { prev_line [: GEDCOM_MAX_LINE_LENGTH - len ( self . _MISSING_DATA_PLACEHOLDER )] }{ self . _MISSING_DATA_PLACEHOLDER } \" elif self . _EMPTY_LINE_RE . match ( prev_line ): # Add the missing data placeholder, but make sure there is a space between it and the tag prev_line = f \" { prev_line } { self . _MISSING_DATA_PLACEHOLDER } \" else : # Add the missing data placeholder prev_line = f \" { prev_line }{ self . _MISSING_DATA_PLACEHOLDER } \" else : skip = False ret . append ( line ) if self . ENTRY_DEBUG : print ( \"REMOVE_CONT_CONC results:\" ) for x in ret : print ( f \" \\t { x } \" ) return ret","title":"Example"},{"location":"reference/parsers/entry/#parsers.entry.Entry.to_col_name_dict","text":"Transform lines into a CSV-file-friendly dictionary of col-title:value pairs Tags are folded into eachother so that one entry can occupy a single row of the CSV file. E.g. 0 @I42@ INDI 1 NAME Leonard Frank /Bartos/ 2 GIVN Leonard Frank 2 NSFX RPh 1 SEX M 1 _UID 4EF44217DF0F40419968D80B5CC5FE8491FB becomes { \"type\": \"INDI\", \"id:\" @I42@\", \"NAME\": \"Leonard Frand /Bartos/\", \"NAME+GIVN\": \"Leonard Frank\", \"NAME+NSFX\": \"RPh\", \"SEX\": \"M\", \"_UID\": \"4EF44217DF0F40419968D80B5CC5FE8491FB\", } Source code in parsers/entry.py def to_col_name_dict ( self ): \"\"\"Transform lines into a CSV-file-friendly dictionary of col-title:value pairs Tags are folded into eachother so that one entry can occupy a single row of the CSV file. E.g. 0 @I42@ INDI 1 NAME Leonard Frank /Bartos/ 2 GIVN Leonard Frank 2 NSFX RPh 1 SEX M 1 _UID 4EF44217DF0F40419968D80B5CC5FE8491FB becomes { \"type\": \"INDI\", \"id:\" @I42@\", \"NAME\": \"Leonard Frand /Bartos/\", \"NAME+GIVN\": \"Leonard Frank\", \"NAME+NSFX\": \"RPh\", \"SEX\": \"M\", \"_UID\": \"4EF44217DF0F40419968D80B5CC5FE8491FB\", } \"\"\" # at minimum, id and type is needed ret = { \"id\" : self . id , \"tag_type\" : self . type } # a stack of active tags. The tags are concatenated together to form column headers active_tags = [] # iterate through the Line objects directly for i , line in enumerate ( self . _lines ): # Pop all no-longer-active tags off of the stack. The current line's depth - 1 # indicates how many of the active tags are still relevant. (The current line contributes # an active tag. Thus, the length of active tags should always equal the depth of the line if line . depth <= len ( active_tags ) + 1 : active_tags = active_tags [: ( line . depth - 1 )] active_tags . append ( line . tag ) # process tag_value. Tags with no value need a placeholder and date tags may need # adjusting depending on force_string_dates if line . tag_value is None : tag_value = self . _EMPTY_LINE_PLACEHOLDER elif ( line . tag == self . _DATE_TAG and self . force_string_dates and not line . tag . startswith ( \"'\" ) ): tag_value = f \"' { line . tag_value } \" else : tag_value = line . tag_value # Ensure unique column headers. E.g. if there are two NAME entries in a record and each # has a GIVN sub-property, the dictionary should look like: # { # \"NAME+GIVN\": \"value\", # \"NAME+GIVN_1\": \"other value\", # } suffix = 0 while self . _ACTIVE_TAG_SEPARATOR . join ( active_tags ) in ret : suffix += 1 active_tags [ - 1 ] = f \" { line . tag }{ self . _SUFFIX_SEPARATOR }{ suffix } \" ret [ \"+\" . join ( active_tags )] = tag_value if self . ENTRY_DEBUG : print ( \"--ENTRY AS DICT--\" ) for k , v in ret . items (): print ( f \" \\t { k } : { v } \" ) return ret","title":"to_col_name_dict()"},{"location":"reference/parsers/entry/#parsers.entry.Line","text":"Source code in parsers/entry.py class Line : _LINE_RE = re . compile ( r \"^(?P<depth>[0-9]+) (?P<tag>[0-9A-Z_]+)(?: (?P<tag_value>.*))?$\" ) \"\"\"Represents a single line of a gedcom file A line has three parts: depth, tag, and tag_value. The third, tag_value, is optional. The format of a line is: {depth} {tag}[ {tag_value}] Seome examples are: 0 INDI @Ixxx@ 1 DEAT 2 DATE 1876 \"\"\" def __init__ ( self , depth : Union [ str , int ], tag : str , tag_value : Optional [ str ] = None ): r \"\"\" Parameters ---------- depth: Union[str, int] The depth of the gedcom file line. Depth is the first part of a line entry. Typically a single digit 0-3 tag: str The tag of the gedcome file line. E.g. \"NAME\", \"BIRT\", or \"_PLAC\" tag_value: Optional[str], default: None The value corresponding to the tag. E.g. \"John \\Cleese\\\" \"\"\" self . depth = depth self . tag = tag self . tag_value = tag_value @staticmethod def get_parts_from_line ( line : str ) -> dict : r \"\"\"Accepts a gedcome line, parses its constituent parts and returns them as a dictionary Parameters ---------- line: str Returns ------- dict with keys \"depth\", \"tag\", and \"tag_value\". All values in the dict are strings, though \"tag_value\" may have a value of None. \"\"\" m = Line . _LINE_RE . match ( line ) if not m : raise ValueError ( f \"Invalid gedcom line recieved: { line } \" ) return m . groupdict () @classmethod def from_str ( cls , line : str ): \"\"\"Accepts a string and returns a Line object\"\"\" return cls ( ** cls . get_parts_from_line ( line )) def to_str ( self ) -> str : \"\"\"Converts a line object to a string\"\"\" ret = f \" { self . depth } { self . tag } \" if self . tag_value is not None : ret = f \" { ret } { self . tag_value } \" return ret @staticmethod def get_depth_from_line ( line : str ) -> str : \"\"\"Returns the depth value from a gedcom file line. E.g. A NAME line may look like '1 NAME Leonard Frank /Bartos/'. Here the depth is 1, meaning this is a first-order property of a base entry. E.g. A SURN line may look like '2 GIVN Leonard Frank'. Here the depth is 2, meaning this is a second-order property of a base entry (a first-order property of a NAME line, probably). \"\"\" return Line . get_parts_from_line ( line = line )[ \"depth\" ] @staticmethod def get_tag_from_line ( line : str ) -> str : \"\"\"Returns the tag name from a gedcom file line. E.g. 'NAME', 'BIRT', 'FAMS'\"\"\" return Line . get_parts_from_line ( line = line )[ \"tag\" ] @staticmethod def get_tag_value_from_line ( line : str ) -> str : \"\"\"Returns the value associated with a line in a gedcom file. If the line has no value, None is returned E.g. the line '1 NAME Dorothy Adela /Popp/` returns 'Dorothy Adela /Popp/` E.g. the line '1 BIRT' returns None \"\"\" return Line . get_parts_from_line ( line = line )[ \"tag_value\" ] @property def line ( self ): return self . _line @line . setter def line ( self , val ): if not isinstance ( val , str ): raise ValueError ( f \"invalid line type of { type ( val ) } \" ) else : self . _line = val @property def depth ( self ): return self . _depth @depth . setter def depth ( self , val ): if not isinstance ( val , ( str , int )): raise ValueError ( f \"invalid depth type of { type ( val ) } \" ) else : self . _depth = int ( val ) @property def tag ( self ): return self . _tag @tag . setter def tag ( self , val ): if not isinstance ( val , str ): raise ValueError ( f \"invalid tag type of { type ( val ) } \" ) else : self . _tag = val @property def tag_value ( self ): return self . _tag_value @tag_value . setter def tag_value ( self , val ): if val is not None and not isinstance ( val , str ): raise ValueError ( f \"invalid tag_value type of { type ( val ) } \" ) else : self . _tag_value = val","title":"Line"},{"location":"reference/parsers/entry/#parsers.entry.Line.__init__","text":"","title":"__init__()"},{"location":"reference/parsers/entry/#parsers.entry.Line.__init__--parameters","text":"!!! depth \"Union[str, int]\" The depth of the gedcom file line. Depth is the first part of a line entry. Typically a single digit 0-3 !!! tag \"str\" The tag of the gedcome file line. E.g. \"NAME\", \"BIRT\", or \"_PLAC\" !!! tag_value \"Optional[str], default: None\" The value corresponding to the tag. E.g. \"John \\Cleese\\\" Source code in parsers/entry.py def __init__ ( self , depth : Union [ str , int ], tag : str , tag_value : Optional [ str ] = None ): r \"\"\" Parameters ---------- depth: Union[str, int] The depth of the gedcom file line. Depth is the first part of a line entry. Typically a single digit 0-3 tag: str The tag of the gedcome file line. E.g. \"NAME\", \"BIRT\", or \"_PLAC\" tag_value: Optional[str], default: None The value corresponding to the tag. E.g. \"John \\Cleese\\\" \"\"\" self . depth = depth self . tag = tag self . tag_value = tag_value","title":"Parameters"},{"location":"reference/parsers/entry/#parsers.entry.Line.from_str","text":"Accepts a string and returns a Line object Source code in parsers/entry.py @classmethod def from_str ( cls , line : str ): \"\"\"Accepts a string and returns a Line object\"\"\" return cls ( ** cls . get_parts_from_line ( line ))","title":"from_str()"},{"location":"reference/parsers/entry/#parsers.entry.Line.get_depth_from_line","text":"Returns the depth value from a gedcom file line. E.g. A NAME line may look like '1 NAME Leonard Frank /Bartos/'. Here the depth is 1, meaning this is a first-order property of a base entry. E.g. A SURN line may look like '2 GIVN Leonard Frank'. Here the depth is 2, meaning this is a second-order property of a base entry (a first-order property of a NAME line, probably). Source code in parsers/entry.py @staticmethod def get_depth_from_line ( line : str ) -> str : \"\"\"Returns the depth value from a gedcom file line. E.g. A NAME line may look like '1 NAME Leonard Frank /Bartos/'. Here the depth is 1, meaning this is a first-order property of a base entry. E.g. A SURN line may look like '2 GIVN Leonard Frank'. Here the depth is 2, meaning this is a second-order property of a base entry (a first-order property of a NAME line, probably). \"\"\" return Line . get_parts_from_line ( line = line )[ \"depth\" ]","title":"get_depth_from_line()"},{"location":"reference/parsers/entry/#parsers.entry.Line.get_parts_from_line","text":"Accepts a gedcome line, parses its constituent parts and returns them as a dictionary","title":"get_parts_from_line()"},{"location":"reference/parsers/entry/#parsers.entry.Line.get_parts_from_line--parameters","text":"line: str","title":"Parameters"},{"location":"reference/parsers/entry/#parsers.entry.Line.get_parts_from_line--returns","text":"dict with keys \"depth\", \"tag\", and \"tag_value\". All values in the dict are strings, though \"tag_value\" may have a value of None. Source code in parsers/entry.py @staticmethod def get_parts_from_line ( line : str ) -> dict : r \"\"\"Accepts a gedcome line, parses its constituent parts and returns them as a dictionary Parameters ---------- line: str Returns ------- dict with keys \"depth\", \"tag\", and \"tag_value\". All values in the dict are strings, though \"tag_value\" may have a value of None. \"\"\" m = Line . _LINE_RE . match ( line ) if not m : raise ValueError ( f \"Invalid gedcom line recieved: { line } \" ) return m . groupdict ()","title":"Returns"},{"location":"reference/parsers/entry/#parsers.entry.Line.get_tag_from_line","text":"Returns the tag name from a gedcom file line. E.g. 'NAME', 'BIRT', 'FAMS' Source code in parsers/entry.py @staticmethod def get_tag_from_line ( line : str ) -> str : \"\"\"Returns the tag name from a gedcom file line. E.g. 'NAME', 'BIRT', 'FAMS'\"\"\" return Line . get_parts_from_line ( line = line )[ \"tag\" ]","title":"get_tag_from_line()"},{"location":"reference/parsers/entry/#parsers.entry.Line.get_tag_value_from_line","text":"Returns the value associated with a line in a gedcom file. If the line has no value, None is returned E.g. the line '1 NAME Dorothy Adela /Popp/ returns 'Dorothy Adela /Popp/ E.g. the line '1 BIRT' returns None Source code in parsers/entry.py @staticmethod def get_tag_value_from_line ( line : str ) -> str : \"\"\"Returns the value associated with a line in a gedcom file. If the line has no value, None is returned E.g. the line '1 NAME Dorothy Adela /Popp/` returns 'Dorothy Adela /Popp/` E.g. the line '1 BIRT' returns None \"\"\" return Line . get_parts_from_line ( line = line )[ \"tag_value\" ]","title":"get_tag_value_from_line()"},{"location":"reference/parsers/entry/#parsers.entry.Line.to_str","text":"Converts a line object to a string Source code in parsers/entry.py def to_str ( self ) -> str : \"\"\"Converts a line object to a string\"\"\" ret = f \" { self . depth } { self . tag } \" if self . tag_value is not None : ret = f \" { ret } { self . tag_value } \" return ret","title":"to_str()"},{"location":"reference/parsers/gedcom_file/","text":"Contains the GedcomFile class which is the main entry point for parsing a .ged file GedcomFile Represents the contents of a Gedcom file. Takes the contents of a gedcom file and provides an interface for interpreting the contents and converting each section to CSV format. Parameters gedcom_str : str The contents of a GEDCOM file as a string no_cont_conc : bool Whether or not to preserve data from CONT (continue) and CONC (concatenate) tags in the gedcom file force_string_dates : bool Date values are prepended with a single quote mark (\"'\") if True. This helps render dates as strings in Microsoft Excel, e.g. Methods get_all_records_csv(encoding=\"utf-8\") Returns a dictionary of CSV format strings. Keys are \"INDI\", \"FAM\", and \"SOUR\". get_section_records_csv(section, encoding=\"utf-8\") Returns the individual records formatted as a CSV Source code in parsers/gedcom_file.py class GedcomFile : \"\"\"Represents the contents of a Gedcom file. Takes the contents of a gedcom file and provides an interface for interpreting the contents and converting each section to CSV format. Parameters ---------- gedcom_str : str The contents of a GEDCOM file as a string no_cont_conc : bool Whether or not to preserve data from CONT (continue) and CONC (concatenate) tags in the gedcom file force_string_dates : bool Date values are prepended with a single quote mark (\"'\") if True. This helps render dates as strings in Microsoft Excel, e.g. Methods ------- get_all_records_csv(encoding=\"utf-8\") Returns a dictionary of CSV format strings. Keys are \"INDI\", \"FAM\", and \"SOUR\". get_section_records_csv(section, encoding=\"utf-8\") Returns the individual records formatted as a CSV \"\"\" def __init__ ( self , gedcom_str : str , no_cont_conc : bool , force_string_dates : bool , ) -> None : self . gedcom_lines = gedcom_str . split ( \" \\n \" ) self . no_cont_conc = no_cont_conc self . force_string_dates = force_string_dates def get_all_records_csv ( self , encoding : str = \"utf-8\" ) -> Dict [ str , str ]: \"\"\"Converts gedcom_str into separate CSV strings for indi, fam, and sour records Parameters ---------- encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- Dict[str, str] A dictionary of entry type to csv strings with the following keys: - \"INDI\": individual entries csv string, - \"FAM\": family entries csv string, - \"SOUR\": source entries csv string, \"\"\" return { \"INDI\" : self . get_section_records_csv ( section = \"indi\" , encoding = encoding ), \"FAM\" : self . get_section_records_csv ( section = \"fam\" , encoding = encoding ), \"SOUR\" : self . get_section_records_csv ( section = \"sour\" , encoding = encoding ), } def get_section_records_csv ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ], encoding : str = \"utf-8\" ) -> str : \"\"\"Returns the records of a type as a CSV formatted string Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section-type to convert to CSV and return encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- str \"\"\" entries = self . _get_section_entries ( section = section ) df = self . _get_entries_df ( entries = entries ) return self . _convert_df_to_csv ( df = df , encoding = encoding ) def _get_entries_df ( self , entries : List [ Entry ]) -> pd . DataFrame : \"\"\"Converts a list of entries into a pandas DataFrame object Parameters ---------- entries : List[Entry] Returns ------- pd.DataFrame \"\"\" return pd . DataFrame ( x . to_col_name_dict () for x in entries ) def _convert_df_to_csv ( self , df : pd . DataFrame , encoding : str = \"utf-8\" ) -> str : \"\"\"Accepts a dataframe and returns it formatted as a CSV string Parameters ---------- df : pd.DataFrame encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- str A CSV-formatted string with the contents of df \"\"\" return df . to_csv ( header = True , index = False , encoding = encoding ) def _get_section_entries ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ]) -> List [ Entry ]: \"\"\"Parses a section of the gedcom string and instantiates Entry items for the section Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section of the gedcom string to process Returns ------- List[Entry] A list of Entry objects, one for each primary 0-level entry in the given section Raises ------ RuntimeError if the section boundaries cannot be determined from the gedcom file. This indicates a mal-formed gedcom file. \"\"\" ret = [] start_line_index = self . _get_section_start_index ( section = section ) end_line_index = self . _get_section_end_index ( section = section ) if ( start_line_index is None ) ^ ( end_line_index is None ): raise RuntimeError ( f \"Cannot determine boundaries of { section } in the provided gedcom string. \\n \" \" Ensure that the GEDCOM file is formatted correctly and try again.\" ) elif start_line_index : assert end_line_index is not None i = start_line_index while i <= end_line_index : j = i + 1 while j < len ( self . gedcom_lines ) and not self . gedcom_lines [ j ] . startswith ( \"0\" ): j += 1 assert j <= end_line_index + 1 assert self . gedcom_lines [ i ] . startswith ( \"0\" ) assert self . gedcom_lines [ j ] . startswith ( \"0\" ) LOG . debug ( f \"RECORD LINES { i } - { j } :\" ) for k in range ( i , j ): LOG . debug ( f \" \\t { self . gedcom_lines [ k ] } \" ) ret . append ( Entry ( lines = self . gedcom_lines [ i : j ], force_string_dates = self . force_string_dates , no_cont_conc = self . no_cont_conc , ) ) i = j return ret def _get_section_start_index ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ]) -> Union [ int , None ]: \"\"\"Returns the section start line index Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section to seek the beginning of Returns ------- Union[int, None] The line index (zero-indexed) of the gedcom string that marks the beginning of the requested section. If None is returned, this indicates the section is absent from the gedcom file \"\"\" pattern = self . _get_entry_regex_pattern ( section = section ) # find first instance of match ret = None for i , line in enumerate ( self . gedcom_lines ): if pattern . match ( line ): ret = i break LOG . debug ( f \"Start index of { section } determined: { ret } \" ) return ret def _get_section_end_index ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ]) -> int : \"\"\"Returns the section end line index Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section to seek the end of Returns ------- Union[int, None] The line index (zero-indexed) of the gedcom string that marks the end of the requested section. If None is returned, this indicates the section is absent from the gedcom file \"\"\" pattern = self . _get_entry_regex_pattern ( section = section ) ret = None i = len ( self . gedcom_lines ) - 1 # start from the end of the gedcom file and work backwards searching for the last line that # matches the provided entry pattern end_found = False while i > 0 and not end_found : if pattern . match ( self . gedcom_lines [ i ]): end_found = True i += 1 # Now start working back forwards to find the end of this indi entry while i < len ( self . gedcom_lines ) and not self . gedcom_lines [ i ] . startswith ( \"0\" ): i += 1 if self . gedcom_lines [ i ] . startswith ( \"0\" ): ret = i - 1 i -= 1 LOG . debug ( f \"End index of { section } determined: { ret } \" ) return ret def _get_entry_regex_pattern ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ]) -> Pattern : \"\"\"Returns a compiled regex pattern for matching 0-level entries for the given section type Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Returns ------- Pattern a compiled regex pattern that will match 0-level entries of the requested type Raises ------ ValueError if the provided section value does not match one of the available patterns \"\"\" if section == \"indi\" : ret = _INDI_REGEX elif section == \"fam\" : ret = _FAM_REGEX elif section == \"sour\" : ret = _SOUR_REGEX else : raise ValueError ( f \"invalid section type ' { section } ' provided\" ) return ret get_all_records_csv ( self , encoding = 'utf-8' ) Converts gedcom_str into separate CSV strings for indi, fam, and sour records Parameters encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns Dict[str, str] A dictionary of entry type to csv strings with the following keys: - \"INDI\": individual entries csv string, - \"FAM\": family entries csv string, - \"SOUR\": source entries csv string, Source code in parsers/gedcom_file.py def get_all_records_csv ( self , encoding : str = \"utf-8\" ) -> Dict [ str , str ]: \"\"\"Converts gedcom_str into separate CSV strings for indi, fam, and sour records Parameters ---------- encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- Dict[str, str] A dictionary of entry type to csv strings with the following keys: - \"INDI\": individual entries csv string, - \"FAM\": family entries csv string, - \"SOUR\": source entries csv string, \"\"\" return { \"INDI\" : self . get_section_records_csv ( section = \"indi\" , encoding = encoding ), \"FAM\" : self . get_section_records_csv ( section = \"fam\" , encoding = encoding ), \"SOUR\" : self . get_section_records_csv ( section = \"sour\" , encoding = encoding ), } get_section_records_csv ( self , section , encoding = 'utf-8' ) Returns the records of a type as a CSV formatted string Parameters section : Literal[\"indi\", \"fam\", \"sour\"] Which section-type to convert to CSV and return encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns str Source code in parsers/gedcom_file.py def get_section_records_csv ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ], encoding : str = \"utf-8\" ) -> str : \"\"\"Returns the records of a type as a CSV formatted string Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section-type to convert to CSV and return encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- str \"\"\" entries = self . _get_section_entries ( section = section ) df = self . _get_entries_df ( entries = entries ) return self . _convert_df_to_csv ( df = df , encoding = encoding )","title":"gedcom_file"},{"location":"reference/parsers/gedcom_file/#parsers.gedcom_file.GedcomFile","text":"Represents the contents of a Gedcom file. Takes the contents of a gedcom file and provides an interface for interpreting the contents and converting each section to CSV format.","title":"GedcomFile"},{"location":"reference/parsers/gedcom_file/#parsers.gedcom_file.GedcomFile--parameters","text":"gedcom_str : str The contents of a GEDCOM file as a string no_cont_conc : bool Whether or not to preserve data from CONT (continue) and CONC (concatenate) tags in the gedcom file force_string_dates : bool Date values are prepended with a single quote mark (\"'\") if True. This helps render dates as strings in Microsoft Excel, e.g.","title":"Parameters"},{"location":"reference/parsers/gedcom_file/#parsers.gedcom_file.GedcomFile--methods","text":"get_all_records_csv(encoding=\"utf-8\") Returns a dictionary of CSV format strings. Keys are \"INDI\", \"FAM\", and \"SOUR\". get_section_records_csv(section, encoding=\"utf-8\") Returns the individual records formatted as a CSV Source code in parsers/gedcom_file.py class GedcomFile : \"\"\"Represents the contents of a Gedcom file. Takes the contents of a gedcom file and provides an interface for interpreting the contents and converting each section to CSV format. Parameters ---------- gedcom_str : str The contents of a GEDCOM file as a string no_cont_conc : bool Whether or not to preserve data from CONT (continue) and CONC (concatenate) tags in the gedcom file force_string_dates : bool Date values are prepended with a single quote mark (\"'\") if True. This helps render dates as strings in Microsoft Excel, e.g. Methods ------- get_all_records_csv(encoding=\"utf-8\") Returns a dictionary of CSV format strings. Keys are \"INDI\", \"FAM\", and \"SOUR\". get_section_records_csv(section, encoding=\"utf-8\") Returns the individual records formatted as a CSV \"\"\" def __init__ ( self , gedcom_str : str , no_cont_conc : bool , force_string_dates : bool , ) -> None : self . gedcom_lines = gedcom_str . split ( \" \\n \" ) self . no_cont_conc = no_cont_conc self . force_string_dates = force_string_dates def get_all_records_csv ( self , encoding : str = \"utf-8\" ) -> Dict [ str , str ]: \"\"\"Converts gedcom_str into separate CSV strings for indi, fam, and sour records Parameters ---------- encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- Dict[str, str] A dictionary of entry type to csv strings with the following keys: - \"INDI\": individual entries csv string, - \"FAM\": family entries csv string, - \"SOUR\": source entries csv string, \"\"\" return { \"INDI\" : self . get_section_records_csv ( section = \"indi\" , encoding = encoding ), \"FAM\" : self . get_section_records_csv ( section = \"fam\" , encoding = encoding ), \"SOUR\" : self . get_section_records_csv ( section = \"sour\" , encoding = encoding ), } def get_section_records_csv ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ], encoding : str = \"utf-8\" ) -> str : \"\"\"Returns the records of a type as a CSV formatted string Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section-type to convert to CSV and return encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- str \"\"\" entries = self . _get_section_entries ( section = section ) df = self . _get_entries_df ( entries = entries ) return self . _convert_df_to_csv ( df = df , encoding = encoding ) def _get_entries_df ( self , entries : List [ Entry ]) -> pd . DataFrame : \"\"\"Converts a list of entries into a pandas DataFrame object Parameters ---------- entries : List[Entry] Returns ------- pd.DataFrame \"\"\" return pd . DataFrame ( x . to_col_name_dict () for x in entries ) def _convert_df_to_csv ( self , df : pd . DataFrame , encoding : str = \"utf-8\" ) -> str : \"\"\"Accepts a dataframe and returns it formatted as a CSV string Parameters ---------- df : pd.DataFrame encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- str A CSV-formatted string with the contents of df \"\"\" return df . to_csv ( header = True , index = False , encoding = encoding ) def _get_section_entries ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ]) -> List [ Entry ]: \"\"\"Parses a section of the gedcom string and instantiates Entry items for the section Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section of the gedcom string to process Returns ------- List[Entry] A list of Entry objects, one for each primary 0-level entry in the given section Raises ------ RuntimeError if the section boundaries cannot be determined from the gedcom file. This indicates a mal-formed gedcom file. \"\"\" ret = [] start_line_index = self . _get_section_start_index ( section = section ) end_line_index = self . _get_section_end_index ( section = section ) if ( start_line_index is None ) ^ ( end_line_index is None ): raise RuntimeError ( f \"Cannot determine boundaries of { section } in the provided gedcom string. \\n \" \" Ensure that the GEDCOM file is formatted correctly and try again.\" ) elif start_line_index : assert end_line_index is not None i = start_line_index while i <= end_line_index : j = i + 1 while j < len ( self . gedcom_lines ) and not self . gedcom_lines [ j ] . startswith ( \"0\" ): j += 1 assert j <= end_line_index + 1 assert self . gedcom_lines [ i ] . startswith ( \"0\" ) assert self . gedcom_lines [ j ] . startswith ( \"0\" ) LOG . debug ( f \"RECORD LINES { i } - { j } :\" ) for k in range ( i , j ): LOG . debug ( f \" \\t { self . gedcom_lines [ k ] } \" ) ret . append ( Entry ( lines = self . gedcom_lines [ i : j ], force_string_dates = self . force_string_dates , no_cont_conc = self . no_cont_conc , ) ) i = j return ret def _get_section_start_index ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ]) -> Union [ int , None ]: \"\"\"Returns the section start line index Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section to seek the beginning of Returns ------- Union[int, None] The line index (zero-indexed) of the gedcom string that marks the beginning of the requested section. If None is returned, this indicates the section is absent from the gedcom file \"\"\" pattern = self . _get_entry_regex_pattern ( section = section ) # find first instance of match ret = None for i , line in enumerate ( self . gedcom_lines ): if pattern . match ( line ): ret = i break LOG . debug ( f \"Start index of { section } determined: { ret } \" ) return ret def _get_section_end_index ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ]) -> int : \"\"\"Returns the section end line index Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section to seek the end of Returns ------- Union[int, None] The line index (zero-indexed) of the gedcom string that marks the end of the requested section. If None is returned, this indicates the section is absent from the gedcom file \"\"\" pattern = self . _get_entry_regex_pattern ( section = section ) ret = None i = len ( self . gedcom_lines ) - 1 # start from the end of the gedcom file and work backwards searching for the last line that # matches the provided entry pattern end_found = False while i > 0 and not end_found : if pattern . match ( self . gedcom_lines [ i ]): end_found = True i += 1 # Now start working back forwards to find the end of this indi entry while i < len ( self . gedcom_lines ) and not self . gedcom_lines [ i ] . startswith ( \"0\" ): i += 1 if self . gedcom_lines [ i ] . startswith ( \"0\" ): ret = i - 1 i -= 1 LOG . debug ( f \"End index of { section } determined: { ret } \" ) return ret def _get_entry_regex_pattern ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ]) -> Pattern : \"\"\"Returns a compiled regex pattern for matching 0-level entries for the given section type Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Returns ------- Pattern a compiled regex pattern that will match 0-level entries of the requested type Raises ------ ValueError if the provided section value does not match one of the available patterns \"\"\" if section == \"indi\" : ret = _INDI_REGEX elif section == \"fam\" : ret = _FAM_REGEX elif section == \"sour\" : ret = _SOUR_REGEX else : raise ValueError ( f \"invalid section type ' { section } ' provided\" ) return ret","title":"Methods"},{"location":"reference/parsers/gedcom_file/#parsers.gedcom_file.GedcomFile.get_all_records_csv","text":"Converts gedcom_str into separate CSV strings for indi, fam, and sour records","title":"get_all_records_csv()"},{"location":"reference/parsers/gedcom_file/#parsers.gedcom_file.GedcomFile.get_all_records_csv--parameters","text":"encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings.","title":"Parameters"},{"location":"reference/parsers/gedcom_file/#parsers.gedcom_file.GedcomFile.get_all_records_csv--returns","text":"Dict[str, str] A dictionary of entry type to csv strings with the following keys: - \"INDI\": individual entries csv string, - \"FAM\": family entries csv string, - \"SOUR\": source entries csv string, Source code in parsers/gedcom_file.py def get_all_records_csv ( self , encoding : str = \"utf-8\" ) -> Dict [ str , str ]: \"\"\"Converts gedcom_str into separate CSV strings for indi, fam, and sour records Parameters ---------- encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- Dict[str, str] A dictionary of entry type to csv strings with the following keys: - \"INDI\": individual entries csv string, - \"FAM\": family entries csv string, - \"SOUR\": source entries csv string, \"\"\" return { \"INDI\" : self . get_section_records_csv ( section = \"indi\" , encoding = encoding ), \"FAM\" : self . get_section_records_csv ( section = \"fam\" , encoding = encoding ), \"SOUR\" : self . get_section_records_csv ( section = \"sour\" , encoding = encoding ), }","title":"Returns"},{"location":"reference/parsers/gedcom_file/#parsers.gedcom_file.GedcomFile.get_section_records_csv","text":"Returns the records of a type as a CSV formatted string","title":"get_section_records_csv()"},{"location":"reference/parsers/gedcom_file/#parsers.gedcom_file.GedcomFile.get_section_records_csv--parameters","text":"section : Literal[\"indi\", \"fam\", \"sour\"] Which section-type to convert to CSV and return encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings.","title":"Parameters"},{"location":"reference/parsers/gedcom_file/#parsers.gedcom_file.GedcomFile.get_section_records_csv--returns","text":"str Source code in parsers/gedcom_file.py def get_section_records_csv ( self , section : Literal [ \"indi\" , \"fam\" , \"sour\" ], encoding : str = \"utf-8\" ) -> str : \"\"\"Returns the records of a type as a CSV formatted string Parameters ---------- section : Literal[&quot;indi&quot;, &quot;fam&quot;, &quot;sour&quot;] Which section-type to convert to CSV and return encoding : str, default=\"utf-8\" encoding type to use when creating CSV strings. Returns ------- str \"\"\" entries = self . _get_section_entries ( section = section ) df = self . _get_entries_df ( entries = entries ) return self . _convert_df_to_csv ( df = df , encoding = encoding )","title":"Returns"}]}